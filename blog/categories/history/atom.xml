<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: History | Saverio Ferrara]]></title>
  <link href="http://fsferrara.github.io/blog/categories/history/atom.xml" rel="self"/>
  <link href="http://fsferrara.github.io/"/>
  <updated>2018-01-07T01:45:01+01:00</updated>
  <id>http://fsferrara.github.io/</id>
  <author>
    <name><![CDATA[Saverio Ferrara]]></name>
    <email><![CDATA[me@fsferrara.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Early Development of Artificial Intelligence]]></title>
    <link href="http://fsferrara.github.io/early-development-of-artificial-intelligence/"/>
    <updated>2013-10-20T01:37:43+00:00</updated>
    <id>http://fsferrara.github.io/early-development-of-artificial-intelligence</id>
    <content type="html"><![CDATA[<p>Primi sviluppi dell&#8217;Intelligenza Artificiale.</p>

<p>E&#8217; difficile dare una definizione di Intelligenza Artificiale (IA) in quando essa è vista sia dal punto di vista ingegneristico (che punta a costruire macchine intelligenti per assistere l&#8217;uomo), sia dal punto di vista psicologico (che punta a riprodurre nelle macchine le caratteristiche dell&#8217;attività cognitiva umana).</p>

<p>Seppur con idee diverse, i pionieri dell&#8217;IA (McCarthy, Minsky, Rochesterm, e Shannon) videro nel calcolatore digitale uno strumento con capacità di elaborazione ineguagliate, quindi uno strumento adatto al confronto con alcuni aspetti della mente umana.</p>

<p>Si cominciarono a sviluppare i primi programmi relativi ad ambiti ben delimitati in cui c&#8217;erano  solo regole esplicite per l&#8217;elaborazione simbolica e poca conoscenza specializzata. Motivo di questo inizio era la scarsa capacità di memoria e di calcolo dei calcolatori di quei tempi.</p>

<p>Successivamente si parte con lo sviluppo di sistemi esperti, dove la conoscenza specializzata nel campo ci porta ad avere buone prestazioni.</p>

<p>La diffusione di queste tecniche di IA ci conferma il successo dal punto di vista ingegneristico, ma cosa possiamo dire dal punto di vista psicologico?</p>

<p>Cosa implica la costruzione di macchine che riproducono caratteristiche essenziali dell&#8217;attività umana? Dove si colloca l&#8217;IA nell&#8217;ambito delle ricerche sul sistema cervello-mente che coinvolgono le neuroscienze e la psicologia?</p>

<!--more-->


<h2>Turing e la Macchina di Turing Universale</h2>

<p>Abbinando le MdT (Macchine di Turing) alle codifiche di Godel, nasce un modo di codificare le MdT. Si ha inoltre un <em>procedimento effettivo</em> per la codifica e la decodifica.</p>

<p>Dalle MdT codificate, Turing arriva alla macchina universale, che è una particolare MdT che, accettando in input la descrizione di una qualsiasi MdT, riesce a comportarsi come essa.</p>

<p>Dalla <strong>MdT Universale</strong> nasce la nozione di <strong>Macchina Programmabile</strong>.</p>

<p>Da questa considerzione ci si chiese se le macchine possano essere intelligenti. Su questo Turing scrive l&#8217;articolo &#8220;Macchine calcolatrici e intelligenza&#8221;.</p>

<h2>Macchine calcolatrici e intelligenza</h2>

<p>Turing considera la domanda: &#8220;<em>Possono pensare le macchine?</em>&#8220;. In questa domanda i termini <strong>macchina</strong> e <strong>pensare</strong> non sono di facile definizione.</p>

<p>Possiamo definire la parola <strong>macchina</strong> possiamo imporre che la macchina sia composta da tre parti: memoria, unità operativa, e governo; dove la memoria è un deposito di informazioni, l&#8217;unità operativa è la parte atta ad eseguire operazioni, ed il governo coordina l&#8217;unità operativa e la memoria.</p>

<p>Quindi scendendo più in dettaglio riusciamo a definire cos&#8217;è una macchina.</p>

<p>Cosa possiamo invece definire la parola <strong>pensare</strong>? Turing non riesce a farlo.</p>

<p>Per questo pensa di riformulare la domanda &#8220;<em>Possono pensare le macchine?</em>&#8221; con un&#8217;altra. Riformula il problema in termini di un gioco dove si trovano tre persona A (un uomo), B (una donna), e C (un&#8217;interrogante). C è isolato in una stanza, e può comunicare con A e B mediante messaggi di tipo linguistico.</p>

<p>Lo scopo di C, che parla con due individui, è di capire chi è la donna e chi è l&#8217;uomo. B (che è la donna) ha il compito di aiutare l&#8217;interrogante C, mentre lo scopo di A (l&#8217;uomo) è quello di ingannarlo.</p>

<p>La domanda riformulata è: &#8220;<em>Che cosa accadrà se una macchina prende il posto di A nel gioco? La frequenza delle risposte errate da parte di C sarà la stessa di quando il gioco si svolge tra uomini?</em>&#8220;.</p>

<p>Chiamiamo questo <strong>Test di Turing</strong>.</p>

<h3>Test di Turing e Intelligenza</h3>

<p>Superare il test di Turing, non è una condizione né necessaria, né sufficiente per stabilire se un individuo o una macchina è intelligente.</p>

<ul>
<li>Condizione Necessaria: se un essere è intelligente deve necessariamente superare il Test di Turing. Ma ci sono situazioni, come quelle delle persone nello stato locked-in (ad esempio il famoso caso di Piergiorgio Welby), in cui l&#8217;individuo non è in grado di superare il test, ma comunque non possiamo dire che tale individuo non è intelligente.</li>
<li>Condizione Sufficiente: supponiamo una macchina con un programma complicatissimo, che è fatta apposta per superare il Test di Turing. Questa macchina sa solo superare questo test e basta: possiamo definirela intelligente?</li>
</ul>


<p>Quindi il superamento del Test di Turing da parte di una macchina non è né condizione necessaria, né condizione sufficiente per affermare che la macchina stressa sia intelligente.</p>

<h3>Osservazioni all&#8217;articolo</h3>

<p><span style="text-decoration: underline;">Prima Osservazione: Funzionalismo</span></p>

<p>Notiamo che in questo gioco la macchina da risposte di tipo linguistico; infatti Turing divide nettamente le capacità fisiche di un essere umano, dalle capacità intellettuali (o mentali). Questo non è vero nell&#8217;eccezione Darwiniana in cui le capacità mentali di un essere vivente sono di fondamentale importanza per coordinare le capacità motorie, e permettono così di sopravvivere.</p>

<p>Essendo la mente umana composta da materiali diversi da quelli con i quali è costruita una macchina, Turing adotta il funzionalismo, ossia paragona il funzionamento degli oggetti anche se costruiti in modo diverso.</p>

<p><span style="text-decoration: underline;">Seconda Osservazione: La mente funziona a stati discreti</span></p>

<p>I calcolatori digitali sono indubbiamente delle macchine a <em>stati discreti</em>. Ovvero si muovono a scatti improvvisi ben distinguibili l&#8217;uno dall&#8217;altro.</p>

<p>Anche se in realtà in natura niente è discreto; se indaghiamo un calcolatore digitale funziona anch&#8217;esso in modo <em>continuo</em>. Ma consideriamolo una macchina a stati discreti.</p>

<p><em>Ci conviene discretizzare la mente paragonandola ad un calcolatore digitale</em>?</p>

<p><span style="text-decoration: underline;">Terza Osservazione: I calcolatori digitali non sono caotici</span></p>

<p>Dato un input in ingresso ad una macchina riusciamo a predire tutti i suoi stati, ed il suo output, in modo esatto. Nel mondo invece vige la teoria del caos, nella quale piccole variazioni nelle condizioni iniziali producono grandi variazioni nel comportamento a lungo termine di un sistema. Ad esempio il battito d&#8217;ali di una farfalla può essere la causa di un uragano dall&#8217;altra parte del mondo.</p>

<h3>Obiezioni Contrarie all&#8217;argomento principale dell&#8217;articolo</h3>

<p><span style="text-decoration: underline;">Obiezione Teologica:</span> &#8220;Solo Dio ha il potere di creare esseri pensanti&#8221;.</p>

<p>Questa obiezione pone serie restrizioni alla provvidenza divina: chi ci dice che Dio non ci abbia dato il potere di creare macchine pensanti?</p>

<p><span style="text-decoration: underline;">Obiezione della Testa nella Sabbia:</span> Questa è l&#8217;obiezione di chi ha paura delle macchine pensanti. A queste persone piace sentirsi superiori di ogni altra cosa, e si sentono minacciati da questo tentativo di creare macchine pensanti.</p>

<p><span style="text-decoration: underline;">Obiezione Matematica:</span> I teoremi di incompletezza di Godel, ed altri risultati ad esso annessi, dimostrano che le macchine non possono conoscere tutte le verità. Quindi esistono dei limiti, e si sostiene che la mente umana non abbia questi limiti.</p>

<p>Ma non è giusto condannare così i calcolatori; diamo risposte errate anche noi. Inoltre ci possono essere uomini più abili di una macchina, ma possono essere costruite altre macchine più abili di questi uomini. Quindi non ci possono essere uomini più abili di tutte le macchine.</p>

<p><span style="text-decoration: underline;">Obiezione dell&#8217;Autocoscienza</span>: Possiamo dividere la coscienza in &#8220;essere consapevole del proprio stato&#8221;, ed &#8220;essere consapevoli di provare&#8221;. Possiamo costruire macchine con medoti di <strong>Machine Learning</strong> che sono consapevoli del proprio stato, ma non ancora riusciamo ad immaginare macchine che sappiano provare dei sentimenti.</p>

<p><span style="text-decoration: underline;">Obiezioni basate su incapacità varie</span>: ad esempio una macchina è capace di gustare le fragole con la panna.</p>

<p>Queste obiezioni nascono dal fatto che vogliamo far assomigliare le macchine agli essere umani. Ma, non essendo le macchine degli essere umani, è difficile avere un rapporto di amicizia tra un uomo ed una macchina.</p>

<p><span style="text-decoration: underline;">Obiezione di Lady Lovelace:</span> &#8220;La macchina può eseguire solo quello che gli diciamo di fare!&#8221;. Questa obiezione è vecchia e risale ai tempi della macchina universale di Babbage.</p>

<p>Con i moderni metodi di <strong>Machine Learning</strong> possiamo avere delle macchine che riescono ad apprendere, anche se sono formate da un nucleo di base non modificabile. Quindi anche essendo una macchina <em>deterministica</em>, possiamo avere macchine che modificano il proprio comportamento man mano che apprendono nuove regole.</p>

<p><span style="text-decoration: underline;">Obiezione fondata sulla continuità del sistema nervoso:</span> Ancora una volta ci rifacciamo al concetto di funzionalismo, secondo il quale cerchiamo di ottenere solo un comportamento intelligente, e non pretendiamo che internamente le cose funzionino allo stesso modo.</p>

<h3>Possono le macchine pensare?</h3>

<p>Dopo l&#8217;articolo di Turing partono gli studi per costruire macchine in grado di competere con l&#8217;uomo in ambiti intellettuali. Ma quel&#8217;è la strada migliore per iniziare a costruire queste macchine?</p>

<p>L&#8217;<em>IA</em> comincia a sviluppare programmi per calcolatori digitali capaci di svolgere attività molto astratte, come giocare a scacchi.</p>

<p>La <em>robotica</em> invece inizia mettendo in risalto il comportamento intelligente degli esseri viventi, e comincia a costruire dispositivi meccanici che si comportano in modo intelligente.</p>

<p>Parallelamente a queste due nasce anche la branca della <strong>Machine Learning</strong>, un&#8217;intuizione geniale da parte di Turing.</p>

<h2>La cibernetica prima dei calcolatori digitali</h2>

<p>La cibernetica nasce con i sistemi a retroazione. La differenza con il punto di vista di Turing, è che questa volta <span style="text-decoration: underline;">il comportamento intelligente è visto come un comportamento flessibile-adattativo all&#8217;ambiente</span>: c&#8217;è un tentativo di collegare questi sistemi a retroazione ai sistemi biologici, con un conseguente collegamento alla scienza molto più forte.</p>

<p>Da un altro punto di vista notiamo che i cibernetici partono dal basso, costruendo prima sistemi molto semplici, mentre Turing punta a riprodurre l&#8217;attività mentale umana con un macchina&#8230; un compito arduo.</p>

<p>Un primo esempio di sistema a retroazione è la valvola di sfiato della caldaia di una locomotiva a vapore; il suo compito era quello di tenere la pressione costante all&#8217;interno della caldaia, in modo da mantenere costante la velocità del treno. Quindi quando la pressione era troppo alta, la valvola faceva uscire del vapore per farla diminuire.</p>

<p>Questo primo meccanismo di sistema a retroazione puntava a correggere l&#8217;errore, in un ciclo di questo tipo:</p>

<ol>
<li>Osservare l&#8217;output del sistema</li>
<li>Misurare l&#8217;errore</li>
<li>Apportare le modifiche atte a correggere l&#8217;errore</li>
</ol>


<p>Questi meccanismi hanno delle caratteristiche in comune con i sistemi biologici: ad esempio il corpo umano ha un meccanismo simile per controllare la temperatura corporea (la sudorazione).</p>

<p>Rosenblueth, Wiener, e Bigelow, nel loro articolo &#8220;<em>Coportamento, Scopo, e Teleologia</em>&#8221; affermano che i metodi di studio sia per gli organismi viventi, sia per le macchine, sono simili in quanto non sono state trovare delle caratteristiche qualitativamente diverse che caratterizzano un gruppo e non l&#8217;altro.</p>

<p>Possiamo dividere le cause dei mutamenti della natura in quelli provocati da:</p>

<p>&#8211; cause efficienti: è l&#8217;agente che determina operativamente il mutamento</p>

<p>&#8211; cause finali: è l&#8217;intenzione di qualche essere vivente a raggiungere un certo scopo</p>

<p>I cibernetici puntano a descrivere il comportamento intelligente usando solo le cause efficienti, in quanto le cause finali sono caratteristiche dei sistemi biologici.</p>

<p>Come esempio possiamo considerare il comportamento della falena che è stato descritto da uno studioso americano con sole cause efficienti.</p>

<h3>Comportamento, Scopo, e Teleologia</h3>

<p>Il comportamento intelligente può essere diviso in due grosse classi: il comportamento rivolto ad uno scopo (finalizzato), e il comportamento non rivolto ad uno scopo (causale).</p>

<p>Noi ci interessiamo al comportamento rivolto ad uno scopo. Ma cos&#8217;è uno scopo? Abbiamo un <strong>tentativo riduzionista</strong>, <span style="text-decoration: underline;">che riduce lo scopo ad un oggetto, e il suo raggiungimento è uno spostamento spazio/temporale dell&#8217;oggetto stesso</span>.</p>

<p>Su questa visione di vedere uno scopo si inseriscono i critici obiettando il fatto che non sempre lo scopo è un oggetto.</p>

<p>Il comportamento rivolto ad uno scopo può essere diviso a sua volta in comportamento rivolto ad uno scopo con retroazione (o teleologico) o senza retroazione (non teleologico).</p>

<p>Il comportamento rivolto ad uno scopo senza retroazione raggruppa tutti quei casi in cui il movimento è talmente veloce in cui è impensabile che ci sia del tempo utile a modificare il movimento mentre lo si sta facendo. Ad esempio, il comportamento di una rana mentre colpisce una mosca per mangiarsela, è senza retroazione.</p>

<p>Ci interesseremo al comportamento rivolto ad uno scopo con retroazione, nel quale l&#8217;azione che si sta svolgendo è modificabile mentre la si sta facendo. Questo tipo di comportamento è più efficace del comportamento senza retroazione, specialmente quando lo scopo è un oggetto fermo.</p>

<p>Il comportamento rivolto ad uno scopo con retroazione può essere ulteriormente diviso in comportamento rivolto ad uno scopo con retroazione non predittivo o non estrapolativo (la falena che cammina verso la luce) e predittivo o estrapolativo (il gatto che balza per catturare un topo nella posizione in cui il topo dovrebbe stare dopo il balzo, quindi il gatto è capace di estrapolare la posizione del topo in un istante di tempo futuro).</p>

<h3>Intelligenza e Comportamento rivolto ad uno scopo</h3>

<p>Nell&#8217;articolo &#8220;<em>Coportamento, Scopo, e Teleologia</em>&#8221; non sono state individuate le condizioni necessarie e sufficienti per affermare che un agente ha il comportamento intelligente per raggiungere uno scopo. Questo perché il tentativo riduzionista per la descrizione di cosa si intende per scopo ci vincola troppo.</p>

<ul>
<li>Condizione Necessaria: Supponiamo ci sia un cavaliere alla ricerca del Santo Graal. Se il Santo Graal non esiste, come descriviamo lo scopo di questo cavaliere se imponiamo che lo scopo sia un oggetto?</li>
<li>Condizione Sufficiente: Supponiamo una persona si sveglia all&#8217;improvviso durante la notte, e spara un colpo di pistola allo specchio. Come descriviamo lo scopo di questo signore? Il suo intento non era sparare nello specchio, ma l&#8217;ha fatto per motivi che non conosciamo.</li>
</ul>


<p>Quindi la definizione di Scopo come una relazione spazio/temporale relativa ad un oggetto è troppo restrittiva per descrivere il comportamento intelligente rivolto ad uno scopo.</p>

<h3>Il ruolo dei Modelli nella Scienza</h3>

<p>La cibernetica lavora con i <strong>modelli</strong>. Obiettivo della scienza è ottenere la <strong>comprensione</strong> ed il <strong>controllo</strong> di una qualche parte dell&#8217;universo. Ad esempio la lancetta del barometro che si abbassa ha come causa  (comprensione) l&#8217;abbassamento della pressione; ed anche, la cura per una malattia (controllo) mediante antibiotici.</p>

<p>Ma nessuna parte dell&#8217;universo si lascia afferrare senza un minimo di astrazione. I <strong>modelli</strong> ci aiutano proprio a questo: un modello formale (o intellettuale) rappresenta con astrazione un <strong>sistema studiato</strong> (cioè la parte dell&#8217;universo che stiamo studiando).</p>

<p>Possiamo dividere i modelli in:</p>

<ul>
<li><strong>Modello materiale</strong>: rappresentazione del <em>sistema studiato</em> ottenuto mediante un altro sistema, di solito più semplice, ma con proprietà simili al <em>sistema studiato</em>.</li>
<li><strong>Modello Formale</strong>: rappresenta in termini logici il <em>sistema studiato</em> in maniera semplice, con proprietà simili.</li>
</ul>


<p>I modelli materiali sono utili quando:</p>

<p>&#8211; Vogliamo studiare un sistema di un campo inconsueto (sistema studiato), in un campo più familiare (modello meccanico)</p>

<p>&#8211; Il modello materiale permette di svolgere esperimenti in condizioni più favorevoli rispetto a quelle date dal sistema studiato. Ad esempio ci conviene sperimentare nuovi farmaci prima sui topi, e poi sugli umani. Ma su quale base diciamo che un topo è un modello materiale dell&#8217;umano? Lo diciamo secondo alcuni criteri di &#8220;somiglianza&#8221; rispetto al modello originale.</p>

<p>I modelli non sono utili quando:</p>

<p>&#8211; Se il modello formale non rispecchia bene il sistema studiato, anche il modello materiale sarà poco significativo.</p>

<p>&#8211; Se il modello materiale suggerisce esperimenti predittibili dal modello formale, allora esso è superfluo.</p>

<p>Possiamo dividere i problemi in quelli a scatola chiusa e quelli a scatola aperta.</p>

<p>Nei problemi a <strong>scatola chiusa</strong> conosciamo solo alcuni input e possiamo verificare gli output, ma non sappiamo cosa avviene dentro la scatola. <em>La legge di trasformazione è quella legge che mette in relazione l&#8217;input con l&#8217;output</em>. Per scoprire cosa c&#8217;è nella scatola possiamo provare ad aprirla ed individuare altri input e/o altri output in modo da svolgere studi più approfonditi. Man mano che apriamo tutte le scatole trovate durante lo studio, abbiamo un problema a <strong>scatola aperta</strong>.</p>

<p>Nell&#8217;aprire le scatole, e quindi nell&#8217;aggiungere dettagli alla nostra descrizione, facciamo un&#8217;ipotesi di modularità, ipotizzando che gli input individuati siano debolmente accoppiati con gli altri elementi della scatola. Bisogna stare attenti quando si studiano questi problemi a scendere nel dettaglio fino ad un livello per noi soddisfacente, in modo da avere una buona descrizione del problema senza complicarlo in modo eccessivo.</p>

<h2>&#8220;Computer Simulation of Human Thinking&#8221; &#8211; Newell &amp; Simon</h2>

<p>Abbiamo discusso gli sviluppi della prima Cibernetica. Adesso ci spostiamo sul ramo della prima IA, ed esaminiamo il lavoro di Newell &amp; Simon.</p>

<p>Newell &amp; Simon, due neuroscienziati che studiavano la mente, avevano lo scopo di cercare dei <strong>modelli del mentale</strong>, ossia dei <strong>modelli</strong> che rappresentassero l&#8217;attività cognitiva umana.</p>

<p>Quindi volevano costruire dei programmi che simulassero i compiti cognitivi umani in modo psicologicamente realistico.</p>

<p>Per fare ciò si costruirono delle <strong>Microteorie</strong>. Ogni microteoria era relativa ad un particolare categoria di compiti cognitivi, ad esempio giocare a dama: essi chiedevano alla persona sotto esame di giocare a dama e pensare a voce alta, quindi riferire tutti i suoi ragionamenti selettivi ed euristici (introspezione).</p>

<p>Il programma risultante di questo studio, non solo doveva dare gli stessi risultati del ragionamento cognitivo (e quindi supera il test di Turing), ma nel calcolarli doveva elaborare le informazioni nello stesso modo di un essere umano. Quest&#8217;ultima condizione serve ad avere una simulazione psicologicamente realistica del ragionamento umano.</p>

<p>Una volta costruito un modello per un compito cognitivo, abbiamo una microteoria. Newell &amp; Simon volevano trarre un modello della mente combinando tra loro tutte le microteorie ottenute.</p>

<p>La differenza con Turing, è che Newell &amp; Simon consideravano il test di Turing &#8220;debole&#8221; in quando non riguarda i processi del pensiero, ma prende in considerazione solo la prestazione finale.</p>

<h3>Critiche al lavoro di Newell &amp; Simon</h3>

<p><strong>Critica sull&#8217;uso del protocollo verbale</strong></p>

<p>Il protocollo verbale, con il quale i soggetti studiati illustravano il proprio processo di pensiero sono <strong>incompleti</strong> perché non tutti i processi della mente sono accessibili all&#8217;introspezione.</p>

<p>Inoltre questo metodo di studio del mentale è scorretto perché pensare e descrivere cosa si sta pensando sono due compiti concorrenti che possono interferire tra loro.</p>

<p>Si sta studiando il modo di pensare, o il modo in cui un essere umano descrive il proprio pensiero?</p>

<p><strong>Critica sul dominio di applicazione</strong></p>

<p>Le microteorie sono strettamente collegate al particolare problema. Quindi applicando il modello suggerito da una microteoria ad un problema simile a quello di partenza non si hanno buoni risultati.</p>

<p><strong>Critica sul campione di persone</strong></p>

<p>Il campione scelto per eseguire i test è ristretto, e non rispecchia il modo di pensare di tutta la popolazione. Inoltre ogni persona ha un modo particolare di pensare.</p>

<p><strong>Critica sulla modularità</strong></p>

<p>Newell &amp; Simon non fanno ipotesi di modularità sulla mente e la considerano interamente in un&#8217;unica architettura unificata. Successivi studi (Chomsky, Marr, Fodor, ed altri) tentano di dividere la mente in moduli, in modo da poterli studiare indipendentemente.</p>

<h3>Conclusioni</h3>

<p>Il lavoro di Newell &amp; Simon è stato fallimentare, ma il loro contributo all&#8217;IA è stato enorme. Tutt&#8217;oggi le euristiche da loro definite sono molto utilizzate.</p>

<h2>Chomsky ed il Linguaggio Universale</h2>

<p>Un esempio di ipotesi di modularità è il <strong>Linguaggio Universale</strong> di Chomsky. Lui osserva come i bambini nei loro primi anni di vita riescono ad imparare la lingua, e nota che gli stimoli che essi ricevono sono di scarsa qualità per ottenere i risultati che si hanno.</p>

<p>Quindi l&#8217;ipotesi di modularità di Chomsky è che nella nostra mente esiste un modulo di <strong>Grammatica Universale</strong> (UG) che ci aiuta ad imparare il linguaggio parlato.</p>

<p>Quello che ha fatto Chomsky è isolare questo modulo UG dalle restanti parti della mente, e studiarlo a se stante.</p>

<p>Questo è proprio quello che manca nel lavoro fatto da Newell &amp; Simon, in quanto non avendo fatto ipotesi di modularità, non riescono a trovare delle variabili in comune a tutti gli essere umani con le quali è possibile creare un modello di tutta la mente umana.</p>

<h2>David Marr</h2>

<p>Marr, essendo allievo di Chomsky, prende da lui spunto, e nel suo articolo &#8220;Artificial Intelligence &#8211; A Personal View&#8221; espone la sua critica al lavoro di Newell &amp; Simon.</p>

<p>Secondo Marr, un risultato nel campo dell&#8217;IA doveva seguire questi passaggi:</p>

<ol>
<li>Definizione di <strong>cosa</strong> è calcolato, e <strong>perché</strong> è calcolato</li>
<li>Definire <strong>come</strong> calcolarlo, quindi definizione di un algoritmo</li>
<li>Dimostrazione di funzionamento</li>
</ol>


<p>Il &#8220;perché&#8221; non è interessante da definire in quanto è legato alla natura del problema: il mondo è fatto così. Il &#8220;cosa&#8221; invece è molto interessante, in quanto questo passaggio non è stato considerato da Newell &amp; Simon. Infatti è difficile definire &#8220;cosa&#8221; calcolare in modo preciso quando si sta tentando di costruire un modello per l&#8217;intera mente umana.</p>

<p>Marri chiama <em>teorie di tipo 1</em> quelle in cui si riesce a trovare una buona descrizione di cosa è calcolato, e chiama <em>teorie di tipo 2</em> quelle in cui non si è ancora riusciti a dare una descrizione formale.</p>

<h2>Antonio Damasio</h2>

<p>Molti hanno criticato Newell &amp; Simon per mancanza di ipotesi di modularità. In realtà un&#8217;ipotesi di modularità è stata fatta: l&#8217;attività di problem solving della mente umana è considerata indipendente dalle emozioni provate.</p>

<p>Damasio, neurologo e neuroscienziato degli anni 80, nello studiare un caso clinico si accorge che il paziente non è in grado di provare emozioni.</p>

<p>Questo paziente è perfettamente in grado di effettuare ragionamenti razionali, e risponde correttamente a domande a lui poste. Però quando è coinvolto in prima persona non riesce a prendere le decisioni giuste con i suoi ragionamenti.</p>

<p>L&#8217;ipotesi di Damasio è che <em>le emozioni hanno un ruolo importante nel ragionamento pratico</em>.</p>

<p>Test effettuati con questo paziente mostrano che non è in grado di provare emozioni. Ad esempio in una partita a poker non prova tristezza se perde una mano di gioco, oppure riesce a parlare in modo freddo della sua malattia (o di eventi brutti) con freddezza.</p>

<p>Damasio va oltre questa ipotesi e ne formula un&#8217;altra, in cui afferma che, come le emozioni, <em>le immagini mentali hanno un ruolo nel ragionamento pratico</em>.</p>

<p>Supponiamo di essere stati morsi da un cane mentre passeggiavamo nel parco. Dopo qualche giorno se ripensiamo a quel cane, riusciamo ad immaginarlo e a ricostruirci nel nostro <em>buffer visivo</em> la sua immagine. Assieme alla scena ricostruita associamo un&#8217;emozione che può essere bella o brutta a seconda se il morso del cane ci è piaciuto oppure no (ovviamente in questo caso non ci è piaciuto). Quindi in futuro cercheremo di non passare vicino a quel cane perché rischiamo di essere morsi nuovamente: così facendo nel nostro ragionamento pratico elimineremo tutti gli scenari possibili che ci portano nelle vicinanze di quel cane.</p>

<p>Damasio dice con questa ipotesi che il paziente da lui studiato è incapace associare le immagini mentali alle emozioni, e quindi nel suo ragionamento pratico può scegliere un&#8217;azione che lo riporta a commettere un errore già fatto in passato.</p>

<p>Con queste ipotesi Damasio ha cercato di spiegare l&#8217;assenza di pianificazione e di prudenza che ha il suo paziente durante i ragionamenti pratici che lo coinvolgono i prima persona.</p>

<p>Inoltre mostra come le emozioni hanno un ruolo centrale nel ragionamento, e quindi è sbagliato considerarle indipendenti dal problem solving. Quindi sarà possibile progettare macchine con prestazioni pari a quelle degli essere umani anche se non provano emozioni?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Birth of Computer Science]]></title>
    <link href="http://fsferrara.github.io/the-birth-of-computer-science/"/>
    <updated>2013-10-20T01:33:41+00:00</updated>
    <id>http://fsferrara.github.io/the-birth-of-computer-science</id>
    <content type="html"><![CDATA[<p>La nascita dell&#8217;informatica.</p>

<p>Il primo kernel Linux è stato pubblicato nel 1991, l’annuncio del primo sistema operativo della famiglia Windows risale al 1983, la nascita dell&#8217;informatica come disciplina scientifica risale al 1953, il primo calcolatore programmabile digitale al 1941 (Z3 di Zuse); in realtà tutto scaturisce da una storia molto più lunga che parte dagli studi di Leibniz quando non esistevano i calcolatori digitali, e coinvolge grandi studiosi come Frege, Gödel, e Turing.</p>

<!--more-->


<h2>Gottfried Wilhelm von Leibniz</h2>

<p>Leibniz (Lipsia, 21 giugno 1646 – Hannover, 14 novembre 1716), è stato un filosofo, matematico, e logico tedesco. Ai suoi tempi la logica era quella Aristotelica, quindi del tipo soggetto-predicato.</p>

<p>Leibniz fu il primo ad intuire l’<em style="mso-bidi-font-style: normal;">elaborazione simbolica</em> con il suo progetto della <strong>Characteristica Universalis</strong>. L’idea alla base della Cu (Characteristica Universalis) era quella di creare un linguaggio universale per migliorare le comunicazioni politiche, religiose, e commerciali; quindi la Cu doveva essere un linguaggio in grado di guidare ogni sorta di ragionamento.</p>

<p>Il progetto della Cu prevedeva:</p>

<ol>
<li><p><!-- [if !supportLists]-->Una</p>

<p><strong>Lista</strong> dei concetti primitivi e simboli corrispondenti</p></li>
<li><p><!-- [if !supportLists]--></p>

<p><!--[endif]-->Un’</p>

<p><strong>Arte Combinatoria</strong> utile a combinare i concetti primitivi:</p>

<ol>
<li><p><!-- [if !supportLists]--></p>

<p><!--[endif]--></p>

<p><span style="text-decoration: underline;">Ars Iudicandi</span>: procedura di decisione della verità</p></li>
<li><p><!--[endif]--></p>

<p><span style="text-decoration: underline;">Ars Invenendi</span>: procedura di decisione generativa</p></li>
</ol>
</li>
</ol>


<p>Notiamo che l’Ars Iudicandi e l’Ars Invenendi <em>prevedevano l’introduzione nel sistema della Cu di due procedure effettive</em>, ovvero ci doveva essere un procedimento preciso (algoritmo) sia per decidere la verità di una sentenza del linguaggio (Ars Iudicandi), sia per ottenere altre verità dalle verità che già conosciamo (Ars Invenendi).</p>

<p>I concetti di <strong>Procedura Effettiva</strong> e <strong>Calcolo Simbolico</strong> sono dunque nati da quest’idea di Leibniz.</p>

<p>Purtroppo il programma di sviluppare questo linguaggio è solo un progetto di Leibniz che non è mai stato sviluppato. Abbiamo solo dei documenti e schizzi a riguardo, che saranno poi usati da Frege.</p>

<p>Qui notiamo che l’Ars Iudicandi prevede una sorta di predicato dim(x,y), vero quando x è (il numero di) una dimostrazione della formula (di numero) y. Quindi è quasi un esempio compiuto di <strong>Sistema Formale</strong>.</p>

<h2>Immanuel Kant</h2>

<p>Kant (Königsberg, 22 aprile 1724 – Königsberg, 12 febbraio 1804) è stato un filosofo tedesco. Egli scrive un’opera alla fine del ‘700 nella quale diceva: “<em>La matematica è una cosa certa, e noi dobbiamo studiare solo come arrivare a questa certezza. Inoltre ci si può chiedere: perché la matematica è certa? Qual è il suo fondamento?</em>”.</p>

<p>Frege proverà a rispondere a questa domanda.</p>

<h2>Friedrich Ludwig Gottlob Frege</h2>

<p>Frege (Wismar, 8 novembre 1848 – Bad Kleinen, 26 luglio 1925) è stato un matematico, logico e filosofo tedesco, padre della logica matematica moderna.</p>

<p>Frege voleva rispondere alla domanda posta da Kant (<em>“Perché la matematica è certa?”</em>), usando l’intuizione che aveva avuto Leibniz nella sua Characteristica Universalis.</p>

<p>Qui è introdotta la <strong>Tesi Logicista</strong> (o <strong>Programma Logicista</strong>):</p>

<p align="center">
  “La Matematica è riconducibile alla Logica”
</p>


<p>Si afferma che la matematica è logica! Per portare avanti il Programma Logicista, Frege introduce la logica del primo e del secondo ordine come la conosciamo attualmente. Lui la chiamava <em>Ideografia</em>.</p>

<p>Nel 1879 Frege propose l’<em style="mso-bidi-font-style: normal;">Ideografia</em> un “linguaggio in formule del pensiero puro, a imitazione di quello aritmetico” in cui dice: il modo più sicuro di condurre una dimostrazione è quello puramente logico, il quale astrae dalla natura particolare delle cose e si basa soltanto sulle leggi sulle quali si fonda ogni conoscenza.</p>

<p>A supporto della Tesi Logicista, fu introdotto il primo esempio compiuto di <strong>Sistema Formale</strong>, ovvero un sistema che vincola il processo dimostrativo in modo tale che è sempre possibile riconoscere mediante un procedimento algoritmico se una qualsiasi configurazione di simboli è una dimostrazione oppure no.</p>

<p>Questo <em>sistema formale</em> prevedeva:</p>

<ol>
<li><p><!-- [if !supportLists]-->Insieme Finito di</p>

<p><strong>Assiomi Logici</strong>.</p></li>
<li><p><!-- [if !supportLists]--></p>

<p><!--[endif]-->Insieme Finito di</p>

<p><strong>Regole di Inferenza</strong> che, senza introdurre conoscenza implicita, ci permettano di dedurre gli assiomi della Matematica dall’insieme di <em>Assiomi Logici</em>.</p></li>
</ol>


<p>Inoltre ci sono due importanti <strong>Condizioni di Effettività</strong> che specificano un <em>Sistema Formale</em>:</p>

<ul>
<li><p><!-- [if !supportLists]-->L’insieme degli Assiomi Logici è</p>

<p><strong>Effettivamente Decidibile</strong></p></li>
<li>L’insieme delle Dimostrazioni Logiche è <strong>Effettivamente Decidibile</strong></li>
</ul>


<p>In quest’ultima richiesta si intravede qualcosa del teorema di Gödel; si chiede che il predicato dim(x,y) sia effettivamente decidibile!</p>

<p>Come in Leibniz, anche questa volta ci deve essere un procedimento formale (Algoritmo) che ci assicuri le condizioni di effettività. Ma questa volta le condizioni di effettività sono espressamente richieste.</p>

<p>Inoltre Leibniz e Frege hanno obiettivi diversi, il primo vuole un linguaggio universale, mentre il secondo vuole verificare la certezza della matematica (un problema più piccolo rispetto alla definizione di una lingua universale); entrambi usano la logica come strumento per raggiungere il proprio fine epistemologico.</p>

<h2>Bertrand Arthur William Russell</h2>

<p>Frege prosegue con il suo programma logicista puntando a dimostrare gli assiomi della matematica (gli assiomi di Peano) partendo solo dagli <em>assiomi logici</em>. Nel sistema formale definito da Frege si possono individuare:</p>

<ul>
<li>Il principio di <strong>Coestensione</strong>: “data una proprietà P, esiste l’insieme y di tutti gli x che godono della proprietà P”</li>
<li><p><!-- [if !supportLists]-->Il principio del</p>

<p><strong>Terzo Escluso</strong>: almeno uno tra <em>x</em> e <em>not</em> <em>x</em> deve essere vero.</p></li>
</ul>


<p>Russell (Trellech, 18 maggio 1872 – Penrhyndeudraeth, 2 febbraio 1970), è stato un filosofo, logico e matematico gallese. Si interessò al lavoro di Frege, e formulò il famoso Paradosso di Russell, causa della caduta del Programma Logicista.</p>

<p><span style="text-decoration: underline;">Paradosso di Russell</span>: Supponiamo la proprietà: <em>not__(x appartiene ad x)</em></p>

<p>Un elemento che gode di questa proprietà non appartiene a se stesso. Per il principio della coestensione c’è l’insieme di tutti gli elementi che godono di questa proprietà. Quindi diciamo y l’insieme di tutti gli elementi che non appartengono a se stessi. Adesso ci chiediamo: y appartiene a se stesso?</p>

<ul>
<li><p><!-- [if !supportLists]-->Se y appartiene a se stesso allora gode della proprietà di non appartenere a se stesso.</p></li>
<li><p><!-- [if !supportLists]-->Se y non appartiene a se stesso allora per come è definito deve appartenere a se stesso</p></li>
</ul>


<p>In entrambi i casi, grazie al principio del terzo escluso, giungiamo ad una contraddizione (questa è un’<strong>antinomia</strong>).</p>

<p>Russell nel 1901 formulò il paradosso e si rese conto delle conseguenze che avrebbe avuto per il programma logicista. Non esitò a mettersi in contatto con Frege con una lettera nell&#8217;estate del 1902 in cui illustra il paradosso.</p>

<p>Frege prese atto delle conseguenze distruttive per il sistema che aveva costruito in quegli anni e decise di scrivere un&#8217;appendice ai suoi Principî in cui confessava il fallimento della sua opera.</p>

<p>Siamo davanti ad una scelta:</p>

<p class="MsoListParagraph">
  <!-- [if !supportLists]-->&#8211;

  <em> rinunciare al principio del terzo escluso</em>: e quindi rinunciare alla logica classica
</p>


<p>oppure</p>

<p class="MsoListParagraph">
  <!-- [if !supportLists]-->&#8211;

  <em> rinunciare al principio di coestensione</em>: ma in questo caso non si riescono più a derivare gli assiomi della matematica
</p>


<p>Qui il Programma Logicista, e sorge il <span style="text-decoration: underline;">problema della certezza della matematica</span>.</p>

<p>A seguire ci saranno due programmi che puntano a risolvere il problema della certezza della matematica: Il <strong>Programma Intuizionista</strong>, ed il <strong>Programma di Hilbert</strong>.</p>

<h2>Luitzen Egbertus Jan Brouwer</h2>

<p>Brouwer (Overschie, 27 febbraio 1881 – Blaricum, 2 dicembre 1966) è stato un matematico olandese. Fondò la <strong>Scuola Intuizionista (o costruttivista)</strong>, nella quale dubitò</p>

<p>del <em>principio del terzo escluso</em>.</p>

<p>I requisiti del Programma Intuizionista erano:</p>

<ol>
<li><p><!--[endif]-->Eliminazione del Principio del Terzo Escluso su totalità infinite.</p></li>
<li><p>Interpretazione delle dimostrazioni in modo Costruttivista: cioè una dimostrazione di “esiste x tale che P(x)” deve effettivamente esibire un elemento y per il quale è vero P(y).</p></li>
</ol>


<p>Quindi gli intuizionisti puntano a limitare la matematica, eliminando l’uso di proposizioni ideali, come l’infinito in atto (o infinito attuale), che hanno permesso alla matematica di raggiungere ottimi risultati.</p>

<h2>David Hilbert</h2>

<p>Hilbert (Königsberg, 23 gennaio 1862 – Gottinga, 14 febbraio 1943) è stato un matematico tedesco. Rispose agli intuizionisti con il cosiddetto <strong>Programma di Hilbert</strong>.</p>

<p>Al contrario di Frege che voleva dimostrare gli assiomi matematici patendo dagli assiomi logici, Hilbert voleva formalizzare la matematica con degli assiomi e poi verificare la coerenza delle teorie matematiche formalizzate.</p>

<p>Quindi:</p>

<ol>
<li><p><!-- [if !supportLists]--></p>

<p><!--[endif]-->Formalizzare tutte le teorie matematiche</p>

<p><em>“T”</em> con sistemi formali T</p></li>
<li><p><!-- [if !supportLists]--></p>

<p><!--[endif]-->Dimostrare la coerenza di tali sistemi T con</p>

<p><span style="text-decoration: underline;">metodi matematici finitisti</span>.</p></li>
</ol>


<p>Si comincio con la più semplice delle teorie, ossia con l’Aritmetica Elementare. I <em>metodi matematici finitisti</em> non sono mai stati definiti da Hilbert con precisione. Di sicuro sono metodi matematici in cui vengono chiesti i requisiti intuizionisti: quindi no al terzo escluso su totalità infinite e interpretazione costruttivista delle dimostrazioni. Molti concordano che i metodi finitisti sono inclusi nell’aritmetica Primitiva Ricorsiva dove valgono gli assiomi di Peano che descrivono l’aritmetica elementare.</p>

<p>Nasce la meta-matematica, ossia la parte della matematica che consente di studiare la matematica da punti di vista generali. Stiamo cioè usando la matematica stessa per risolvere il <span style="text-decoration: underline;">problema della certezza della matematica</span>.</p>

<p>Nella metamatematica possiamo studiare varie proprietà dei sistemi formali, ad esempio:</p>

<ul>
<li><p><!-- [if !supportLists]--></p>

<p><strong>Coerenza</strong>: se T dimostra A allora non può dimostrare not A</p></li>
<li><p><!-- [if !supportLists]--></p>

<p><strong>Correttezza</strong>: se T dimostra A allora A è vero nella teoria <em style="mso-bidi-font-style: normal;">“T”</em></p></li>
<li><strong>Completezza</strong>: se A è vero nella teoria <em>“T”</em> allora T dimostra A</li>
</ul>


<p>Notiamo che la correttezza di un sistema formale T implica la sua coerenza.</p>

<p>Ricapitolando Hilbert con il suo <strong>Programma della Coerenza</strong> (che è solo una parte del <strong>Programma di Hilbert</strong>) vuole dimostrare la coerenza della matematica utilizzando la matematica stessa.</p>

<h2>Principia Mathematica (PM)</h2>

<p>I Principia Mathematica, scritti da Russell e Whitehead tra il 1910 e il 1913, rappresentano un’importante tentativo di formalizzare la matematica con la logica. Traggono origine dal lavoro di Frege.</p>

<p>Chiameremo PM il sistema formale formalizzato in questo lavoro.</p>

<h2>Kurt Gödel</h2>

<p>Gödel (Brno, 28 aprile 1906 – Princeton, 14 gennaio 1978) è stato un matematico, logico e filosofo statunitense di origine austro-ungarica, noto soprattutto per i suoi lavori sull&#8217;incompletezza delle teorie matematiche. Gödel è ritenuto uno dei più grandi logici di tutti i tempi insieme a Frege e Aristotele.</p>

<p>Gödel si interessa al Programma di Hilbert, e formula il suo <strong>primo teorema di incompletezza</strong>:</p>

<p style="margin-left: 35.4pt;">
  <em>Se PM è coerente, allora esiste una formula G nel linguaggio L(PM) tale che G è vera e non è dimostrabile in PM ne G ne not G</em>
</p>


<p>Ne segue come corollario il <strong>secondo teorema di incompletezza</strong>:</p>

<p style="margin-left: 35.4pt;">
  <em>Se PM è coerente, e dato che la coerenza di PM è esprimibile all’interno di PM stesso (consis(PM) appartiene a L(PM)) allora in PM non è dimostrabile consis(PM)</em>
</p>


<p>Il <strong>secondo teorema di incompletezza</strong> è quello che fa cadere il <strong>Programma di Hilbert</strong> poiché afferma che non possiamo dimostrare la coerenza di PM all’interno di PM stesso,</p>

<p>cioè non possiamo dimostrare la coerenza della matematica all’interno della matematica stessa.</p>

<p>Però i teoremi di incompletezza si riferiscono al <strong>Sistema Formale</strong> PM. Per far cadere definitivamente il Programma di Hilbert bisognava generalizzare i teoremi di incompletezza a qualsiasi <strong>Sistema Formale</strong> che contiene l’aritmetica elementare.</p>

<h2>Generalizzazione dei Teoremi di Incompletezza</h2>

<p>Vogliamo generalizzare i teoremi di incompletezza in questo modo:</p>

<p><em>Per ogni sistema formale S tale che:</em></p>

<ol>
<li><p><!-- [if !supportLists]--></p>

<p><em>S contiene P (Aritmetica di Peano)</em></p></li>
<li><p><!-- [if !supportLists]--></p>

<p><em>S soddisfa la <strong>condizioni di effettività</strong> di Frege</em></p>

<ul>
<li><p><!-- [if !supportLists]--></p>

<p> <em>a) L’insieme degli assiomi è effettivamente decidibile</em></p></li>
<li><p><!-- [if !supportLists]--></p>

<p><em>b) L’insieme delle dimostrazioni è effettivamente decidibile</em></p></li>
</ul>
</li>
<li><p><!-- [if !supportLists]--></p>

<p><em>S è coerente</em></p></li>
</ol>


<p><em>Allora per S valgono i teoremi di incompletezza</em></p>

<p>Le ipotesi 1 e 3 sono ben precise. L’ipotesi 2.a e 2.b invece no! Infatti esse chiedono di avere due funzioni <strong>effettivamente calcolabili</strong> f(x) e g(Y) le quali ci decidano rispettivamente le formule ben formate di S e le dimostrazioni di S.</p>

<p>Questo è il punto di snodo tra i fondamenti della matematica e la nascita dell’informatica. Infatti una funzione è effettivamente calcolabile se esiste un algoritmo per essa.</p>

<p>Ma quale’è il concetto di algoritmo? Quali sono le funzioni calcolabili mediante un procedimento di calcolo (algoritmo)?</p>

<p>Tutt’ora non esiste un concetto di algoritmo preciso. La classe di tutti gli algoritmi è delineata con la tesi di Church-Turing, la quale essendo una tesi non può essere dimostrata.</p>

<h2>Alan Mathison Turing</h2>

<p>Turing (Londra, 23 giugno 1912 – Wilmslow, 7 giugno 1954) è stato un matematico, logico e crittanalista britannico, considerato uno dei padri dell&#8217;informatica.</p>

<p>Lavorò alla generalizzazione del teorema di Gödel, tentando di rispondere alla domanda: <em>“che cos’è una funzione parzialmente calcolabile mediante un procedimento di calcolo (algoritmo)?”</em>.</p>

<p>Church a quei tempi lavorava alla stessa domanda definendo la classe delle funzioni matematiche PRF, per poi arrivare ad un procedimento di calcolo (λ-calcolo).</p>

<p>Turing invece cominciò questo lavoro cominciando a definire il procedimento di calcolo (definito dalla <strong>Macchina di Turing</strong>), per poi arrivare alla classe di tutte le funzioni calcolabili da una <strong>Macchina di Turing</strong>.</p>

<p>Per definire la sua Macchia di Turing (d’ora in poi MdT), Turing osservo il comportamento di un essere umano che calcola. Quindi individua una serie di restrizioni:</p>

<ol>
<li><p><!-- [if !supportLists]-->L’umano effettua dei calcoli aiutandosi con un foglio. Nel caso di una macchina possiamo pensare ad un nastro potenzialmente infinito fatto di caselle contigue. In ogni casella possiamo</p>

<p>scrivere un simbolo appartenente ad un alfabeto.</p></li>
<li><p><!-- [if !supportLists]-->Limiti all’uso del nastro</p>

<ul>
<li><p><!-- [if !supportLists]-->a.</p>

<p><!--[endif]-->Limite Percettivo: c’è un limite superiore B al numero di caselle contigue osservabili in un istante (questo implica che ci si può spostare sul nastro per vedere le prossime B caselle).</p></li>
<li><p><!-- [if !supportLists]-->b.</p>

<p><!--[endif]-->Limite di Memoria: l’alfabeto dei simboli scrivibili sul nastro è finito poiché l’essere umano non riesce a distinguere e ricordareinfiniti simboli.</p></li>
</ul>
</li>
<li><p><!-- [if !supportLists]-->Il comportamento dipende dallo stato mentale (stato di memoria) dell’essere umano. Questo stato mentale dipende dalle azioni fatte precedentemente. Senza indagare molto sul cervello umano, imponiamo che questi stati siano in numero finito (deciso a priori).</p></li>
<li><p><!-- [if !supportLists]-->Limitiamo il comportamento dell’essere umano che calcola, senza perdita di generalità, al compimento di un’azione per volta:</p>

<ul>
<li><p><!-- [if !supportLists]-->a.</p>

<p><!--[endif]-->Si può cambiare il contenuto solo delle caselle osservate</p></li>
<li><p><!-- [if !supportLists]-->b.</p>

<p><!--[endif]-->Ci si può spostare di un numero L di caselle per volta</p></li>
<li><p><!-- [if !supportLists]-->c.</p>

<p><!--[endif]-->Si può cambiare lo stato mentale</p></li>
</ul>
</li>
<li><p><!-- [if !supportLists]-->Il calcolo è fatto in maniera Deterministica, dato lo stesso input otteniamo sempre lo stesso output</p></li>
</ol>


<p>Ma come imponiamo la condizione di determinismo?</p>

<p>Consideriamo tutte le possibili azioni che può fare l’essere umano durante il calcolo. Diciamo C l’insieme di tutte le possibili coppie <stato mentale, configurazione dei simboli osservati>. Per ogni elemento di C si può scegliere di fare un’azione a scelta contenuta nell’insieme possibili di azioni A (scrittura di un simbolo, spostamento a destra, spostamento a sinistra, cambiamento di stato mentale). Definiamo l’insieme di tutte le possibili istruzioni I=CxA. L’insieme delle istruzioni come definito contiene delle istruzioni che definiscono un algoritmo <strong>non deterministico</strong>, poiché a parità di stato mentale e configurazioni di simboli osservati, possiamo trovare istruzioni che effettuano azioni diverse. Poniamo qui una condizione di <strong>determinismo</strong>, chiedendo di avere come insieme di istruzioni solo un sottoinsieme di I nel quale non compaiano istruzioni che possono essere applicate nello stesso stato del calcolo.</p>

<p>Questa è l’analisi dell’essere umano che calcola.</p>

<p>Adesso definiamo una macchina che simulerà il comportamento di calcolo dell’essere umano. Questa macchina avrà delle configurazioni interne q, che corrispondono agli stati mentali dell’umano. Lavora su un nastro osservando ad ogni nastro un numero B di caselle contigue, e può spostarsi di un numero L di caselle a destra o a sinistra. Può usare i simboli dell’alfabeto per scrivere sulla porzione di nastro osservata, e può cambiare la sua configurazione interna. Questa macchina riproduce il comportamento di calcolo di un essere umano.</p>

<p>Ponendo i vincoli B=1 e L=1 abbiamo proprio la definizione di <strong>Macchina di Turing</strong> (MdT). Chiamiamo classe delle funzioni Turing calcolabili (o T-calcolabili), la classe delle funzioni calcolabili con una MdT.</p>

<p>Turing arriva a formulare la seguente tesi:</p>

<p align="center">
  “Ogni funzione calcolabile da un essere umano mediante algoritmo è una funzione T-calcolabile”
</p>


<p>Notiamo che questa tesi è però ristretta alle funzioni calcolate da un essere umano, e non da un qualsiasi agente di calcolo (come un calcolatore). Proviamo ad estendere questa tesi in questo modo:</p>

<p align="center">
  “Ogni funzione calcolabile da un calcolatore mediante algoritmo è una funzione T-calcolabile”
</p>


<p>Per arrivare alla tesi di Church-Turing, osserviamo che i limiti B ed L sono soggetti ai limiti della fisica: la teoria delle relatività ci vieta di oltrepassare la velocità della luce. Inoltre in una singola cella di nastro possiamo registrarci un simbolo preso da un alfabeto finito, perché assumiamo che la materia (del nastro) abbia un vincolo di atomicità, ma su questo non è ancora stata formulata alcuna teoria scientifica.</p>

<p>Considerando i limiti della fisica possiamo riscrivere la tesi ed ottenere finalmente la <strong>Tesi di Church-Turing</strong>:</p>

<p align="center">
  “Ogni funzione calcolabile da un algoritmo è una funzione T-calcolabile”
</p>


<p>Con questa tesi sono stati generalizzati i teoremi di incompletezza di Gödel, chiedendo che le funzioni f(x) e g(Y) siano T-calcolabili. Cade definitivamente il <strong>Programma di Hilbert</strong>,</p>

<p>e il suo tentativo di verificare la certezza della matematica.</p>

<h2>Sviluppi futuri</h2>

<p>Quindi dal problema della matematica è nata la MdT, e Turing stesso definì la <strong>Macchina di Turing Universale</strong>, la quale è programmabile proprio come un moderno calcolatore digitale.</p>

<p>Da questo nasce il ramo dell’Intelligenza Artificiale (IA), e più in generale dell’Informatica.</p>
]]></content>
  </entry>
  
</feed>
