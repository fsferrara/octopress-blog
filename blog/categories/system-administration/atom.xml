<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: System Administration | Saverio Ferrara]]></title>
  <link href="http://fsferrara.github.io/blog/categories/system-administration/atom.xml" rel="self"/>
  <link href="http://fsferrara.github.io/"/>
  <updated>2018-01-06T00:40:36+01:00</updated>
  <id>http://fsferrara.github.io/</id>
  <author>
    <name><![CDATA[Saverio Ferrara]]></name>
    <email><![CDATA[me@fsferrara.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running Containers With Docker]]></title>
    <link href="http://fsferrara.github.io/running-containers-with-docker/"/>
    <updated>2015-04-03T17:03:29+00:00</updated>
    <id>http://fsferrara.github.io/running-containers-with-docker</id>
    <content type="html"><![CDATA[<p><strong>Docker</strong> is an open platform for developers and sysadmins to build, ship, and run distributed applications. Consisting of <strong>Docker Engine</strong>, a portable, <em>lightweight runtime and packaging tool</em>, and <strong>Docker Hub</strong>, a <em>cloud service for sharing applications and automating workflows</em>, Docker enables apps to be quickly assembled from components and eliminates the friction between development, QA, and production environments. As a result, IT can ship faster and run the same app, unchanged, on laptops, data center VMs, and any cloud.</p>

<p>This post describes how to run Docker machines with the help of Boot2Docker.</p>

<!--more-->


<h2>Boot2Docker {#boot2docker}</h2>

<p>Boot2Docker is a lightweight Linux distribution made specifically to run Docker containers. It is currently designed and tuned <strong>for development</strong>. Using it for <em>any kind of production workloads at this time is highly discouraged</em>.</p>

<p>After boot2docker installation, we can download the boot2docker-vm by typing this command:</p>

<pre><code>saverio@mstar:boot2docker &gt; boot2docker init
</code></pre>

<p>this will download and install into <strong>VirtualBox</strong> a VM.</p>

<pre><code>saverio@mstar:boot2docker &gt; VBoxManage list vms
"boot2docker-vm" {0c34b443-1f74-44c6-88cb-f8cb5fd885c9}
</code></pre>

<p>The boot2docker-vm VM is switched off. To urn it on type the command:</p>

<pre><code>saverio@mstar:boot2docker &gt; boot2docker up
Waiting for VM and Docker daemon to start...
.........................ooooooooooooooooooooooooo
Started.
Writing /Users/saverio/.boot2docker/certs/boot2docker-vm/ca.pem
Writing /Users/saverio/.boot2docker/certs/boot2docker-vm/cert.pem
Writing /Users/saverio/.boot2docker/certs/boot2docker-vm/key.pem

To connect the Docker client to the Docker daemon, please set:
    export DOCKER_HOST=tcp://192.168.59.103:2376
    export DOCKER_CERT_PATH=/Users/fferrara/.boot2docker/certs/boot2docker-vm
    export DOCKER_TLS_VERIFY=1
</code></pre>

<p>Boot2Docker is now up and running.</p>

<p>The Next step is to set up a Docker machine. <a href="https://hub.docker.com/">Docker Hub</a> hosts a collection of docker machines.</p>

<p>Boot2Docker sets up two <strong>network adaptors</strong>, one using NAT to allow the VM to download images and files from the internet, and a host only network that Docker container’s ports will be exposed on.</p>

<p>To expose a port you should use a command like this one</p>

<pre><code>docker run --name nginx-test -d -p 80:80 nginx
</code></pre>

<p>To start practicing with <strong>Docker</strong> let’s ssh-ing into the running boot2docker vm.</p>

<pre><code>saverio@mstar:boot2docker &gt; boot2docker ssh
                        ##        .
                  ## ## ##       ==
               ## ## ## ##      ===
           /""""""""""""""""\___/ ===
      ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
           \______ o          __/
             \    \        __/
              \____\______/
 _                 _   ____     _            _
| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __
| '_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ '__|
| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &lt;  __/ |
|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|
Boot2Docker version 1.5.0, build master : a66bce5 - Tue Feb 10 23:31:27 UTC 2015
Docker version 1.5.0, build a8a31ef
docker@boot2docker:~$
</code></pre>

<h2>Docker {#docker}</h2>

<p>The Docker Engine consists of two parts: a daemon, a server process that manages all the containers, and a client, which acts as a remote control for the daemon.</p>

<p>If you’re loggeg into the boot2docker machine, you can check if the docker daemon is running.</p>

<pre><code>docker@boot2docker:~$ docker version
Client version: 1.5.0
Client API version: 1.17
Go version (client): go1.4.1
Git commit (client): a8a31ef
OS/Arch (client): linux/amd64
Server version: 1.5.0
Server API version: 1.17
Go version (server): go1.4.1
Git commit (server): a8a31ef
</code></pre>

<p>This will verify that the daemon is running and that you can connect to it. If you can see the version number you know you are all set.</p>

<p>I found very useful the [interactive tutorial(<a href="https://www.docker.com/tryit/">https://www.docker.com/tryit/</a>) because the best way to understand Docker is to try it!</p>

<h3>Searching for images {#searchingforimages}</h3>

<p>The easiest way to get started is to use a container image from someone else. Container images are available on the Docker Hub Registry, a cloud-based collection of applications. You can find them online at Docker Hub as well <em>through the Docker Engine client command line</em>.</p>

<p>To search for a container, you can use the command <em>docker search</em>. For example:</p>

<pre><code>docker@boot2docker:~$ docker search tutorial
NAME                                       DESCRIPTION   STARS     OFFICIAL   AUTOMATED
learn/tutorial                                           8
</code></pre>

<p>Searched for a “tutorial” container.</p>

<h3>Downloading container images {#downloadingcontainerimages}</h3>

<p>Container images can be downloaded easily using <em>docker pull</em>. For images in the Docker Hub Registry, the name you specify is constructed as /.</p>

<p>To download learn/tutorial container:</p>

<pre><code>docker@boot2docker:~$ docker pull learn/tutorial
Pulling repository learn/tutorial
8dbd9e392a96: Download complete
Status: Downloaded newer image for learn/tutorial:latest
</code></pre>

<p>With a container Docker can download several layers because a docker images can consists of several layers.</p>

<h3>Run a container {#runacontainer}</h3>

<p>You can think of containers as a process in a box. The box contains everything the process might need, so it has the filesystem, system libraries, shell and such, but by default none of these are running. You <em>start</em> a container by running a process in it.</p>

<p>The command docker run takes a minimum of two arguments:</p>

<ol>
<li>an image name, and</li>
<li>the command you want to execute within that image.</li>
</ol>


<p>So, for the learn/tutorial container, it is:</p>

<pre><code>docker@boot2docker:~$ docker run learn/tutorial echo "hello world"
hello world
</code></pre>

<p>With this you have just started a container and executed a program inside of it, when the program stopped, so did the container.</p>

<h3>Installing things {#installingthings}</h3>

<p>Next we are going to install a simple utility, ping, in the container. The image is based upon ubuntu, so you can run the command <em>apt-get install -y ping</em> in the container.</p>

<p>Note that even though the container stops right after a command completes, the changes are not forgotten.</p>

<pre><code>docker@boot2docker:~$ docker run learn/tutorial apt-get install -y ping
Reading package lists...
Building dependency tree...
The following NEW packages will be installed:
  iputils-ping
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 56.1 kB of archives.
After this operation, 143 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu/ precise/main iputils-ping amd64 3:20101006-1ubuntu1 [56.1 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 56.1 kB in 0s (276 kB/s)
Selecting previously unselected package iputils-ping.
(Reading database ... 7545 files and directories currently installed.)
Unpacking iputils-ping (from .../iputils-ping_3%3a20101006-1ubuntu1_amd64.deb) ...
Setting up iputils-ping (3:20101006-1ubuntu1) ...
</code></pre>

<p>That worked! You have installed a program on top of a base image. Your changes to the filesystem have been kept, but are not yet saved.</p>

<h3>Save your changes {#saveyourchanges}</h3>

<p>After you make changes (by running a command inside a container), you probably want to save those changes. This will enable you to start from this point later. With Docker, the process of saving the state is called <strong>committing</strong>. Commit basically saves the difference between the old image and the new state.</p>

<p>To do that there are several steps. First use <em>docker ps -l</em> to find the ID of the container you created by installing ping.</p>

<pre><code>docker@boot2docker:~$ docker ps -l
CONTAINER ID        IMAGE                   COMMAND                CREATED             STATUS                     PORTS               NAMES
3cba51f3bedc        learn/tutorial:latest   "apt-get install -y    3 minutes ago       Exited (0) 3 minutes ago                       modest_cori
</code></pre>

<p>The id is 3cba51f3bedc.</p>

<p>The second step is to actually commit the changes:</p>

<pre><code>docker@boot2docker:~$ docker commit 3cba51f3bedc learn/ping
86d9da396ee3c8d9d00326838999050d75bf831a016e4a6f0611edd5f62a624b
</code></pre>

<p>That worked! Please take note that Docker has returned a new ID. This ID is the image ID.</p>

<h3>Run your new image {#runyournewimage}</h3>

<p>You have built a complete, self-contained image with the ‘ping’ utility installed named <strong>learn/ping</strong>. Your image can now run on any host that runs Docker.</p>

<p>Let’s try it now with a ping to the host google.com:</p>

<pre><code>docker@boot2docker:~$ docker run learn/ping ping google.com
PING google.com (216.58.210.46) 56(84) bytes of data.
64 bytes from lhr14s23-in-f14.1e100.net (216.58.210.46): icmp_req=1 ttl=61 time=37.3 ms
64 bytes from lhr14s23-in-f14.1e100.net (216.58.210.46): icmp_req=2 ttl=61 time=36.5 ms
64 bytes from lhr14s23-in-f14.1e100.net (216.58.210.46): icmp_req=3 ttl=61 time=44.2 ms
^C
--- google.com ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 8019ms
rtt min/avg/max/mdev = 35.384/37.963/44.248/2.814 ms
</code></pre>

<p>That worked! Note that normally you can use one of Ctrl-C, Ctrl-P, or Ctrl-Q to disconnect (I don’t know why on my Mac none of those three worked). The container will keep running until it will disconnect automatically.</p>

<p>Your image is now a running container. Using <strong>docker ps</strong> we can see a list of all running containers and using <strong>docker inspect</strong>. We can see useful information about this container.</p>

<h3>Push your image to the Docker Hub Registry {#pushyourimagetothedockerhubregistry}</h3>

<p>Now that you have verified that your image works, you can share it with others. Remember that you pulled (downloaded) the learn/tutorial image from the Registry? By pushing (uploading) images that you build, you can easily retrieve them to use on other hosts as well as share them with other users.</p>

<p>To do that the command <strong>docker push</strong> is used:</p>

<pre><code>docker@boot2docker:~$ docker push learn/ping
The push refers to a repository [learn/ping] (len: 1)
Sending image list

Please login prior to push:
Username:
</code></pre>

<p>Ops… it requires to be registered to Docker Hub so that’s all for now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Planning a Cluster for Hadoop BigData]]></title>
    <link href="http://fsferrara.github.io/planning-cluster-hadoop-bigdata/"/>
    <updated>2014-02-21T19:39:20+00:00</updated>
    <id>http://fsferrara.github.io/planning-cluster-hadoop-bigdata</id>
    <content type="html"><![CDATA[<p>This post is about how to plan, for the first time, a cluster for Apache Hadoop and HBase. Hadoop, together with its friends, enable us to elaborate a large amount of data in a cheaply way: by large I mean data large about 100 gigabytes and above.</p>

<p>Hadoop implements the MapReduce framework, that is a way to take a query (or Job) over a dataset, divide it in several queries (or Tasks), and the run these queries in parallel over multiple node of a cluster. Nothing new until now, this looks like the divide-et-impera paradigm: the innovation lies in the fact that the cluster node that is in charge of executing a task has already the data on which process the query. So we are not moving data in order to elaborate them, but we&#8217;re assigning task on the right cluster node that already has the data!</p>

<!--more-->


<p>To distribute data across the cluster nodes, Hadoop has its own file system: HDFS (Hadoop Distributed File System), which can handle about 30PB (Petabyte) of data.</p>

<p>The drawback is that HDFS does not provide a way to have a random access to the data.</p>

<p>In order to have a Random access to the data, you can use HBase, a NoSQL and column-oriented database that run on top of HDFS. Unlike direct access to HDFS, HBase can handle about 1PB (Petabyte) of data, and the performances are 4-5 times slower.</p>

<p>Therefore Apache Hadoop is a software framework that supports large-scale distributed data analysis on commodity servers. It is critical to accurately predict the workloads for the tasks to be run. Hadoop and HBase workloads vary a lot based on the effective use, and for this reason it is really hard to correctly estimate the workloads and the amount of storage. In order to make these estimations correctly, a suitable technique is to start with a pilot project, measure the workloads, and then scale the pilot environment in order to fulfil other needs.</p>

<h2>Software components in an Hadoop Cluster</h2>

<p>There are several components in the Hadoop environment, some are:</p>

<ul>
<li><strong>HDFS</strong>

<ul>
<li><p><strong>NameNode</strong>: is a <em>master</em> node for HDFS file system.</p>

<p>Actually it doesn&#8217;t contains data and manage its slaves called DataNode</p></li>
<li><strong>DataNode</strong>: is a <em>slave</em> node for HDFS file system.</li>
<li><strong>Secondary NameNode</strong>: it is not required, but it is suggested to have a backup node for the main NameNode.</li>
</ul>
</li>
<li><strong>MapReduce</strong>

<ul>
<li><strong>JobTracker</strong>: is a <em>master</em> node for MapReduce framework.</li>
<li><strong>TaskTracker</strong>: is a <em>slave</em> node for MapReduce framework.</li>
</ul>
</li>
<li><strong>HBase</strong>

<ul>
<li><strong>HBase Master</strong>: is a <em>master</em> node for HBase.</li>
<li><strong>RegionServer</strong>: is a <em>slave</em> node for HBase.</li>
<li><strong>Zookeeper</strong>: is a separate component required by HBase, used to manage the cluster.</li>
</ul>
</li>
</ul>


<p>We can rearrange these components by separating masters from slaves.</p>

<ul>
<li><strong>Masters</strong>

<ul>
<li>HDFS NameNode</li>
<li>MapReduce JobTracker</li>
<li>HBase Master</li>
</ul>
</li>
<li><strong>Slaves</strong>

<ul>
<li>HDFS DataNode</li>
<li>MapReduce TaskTracker</li>
<li>HBase RegionServer</li>
</ul>
</li>
</ul>


<p>Masters should be on a reliable cluster node: they should be always available. Slaves, instead, are frequently decommissioned for maintenance. For this reason it it highly recommended to always separate masters from slaves and, additionally, task workloads executed on the slaves should not impact the master nodes.</p>

<p>It is extremely important to deploy together DataNodes, TaskTrackers, and RegionServers, in order to achieve an optimal data locality (this is the principle underlying the MapReduce framework). We will call <strong>SlaveNode</strong> a cluster node with a DataNode, a TaskTracker, and a RegionServer.</p>

<h2>A typical Apache Hadoop Cluster</h2>

<p>Typically, a medium size Hadoop cluster consists in a set of rack-servers (actually it is possible to use blade servers, but this article use rack servers as example): let&#8217;s say that we have four half-size rack cabinets each is 22U tall. The first rack cabinet should be dedicated only to accommodate nodes that are always available such as NameNode (primary and secondary), JobTracker, and HBase Master. The other two rack cabinets should contain only SlaveNodes.</p>

<p>All nodes in a rack should be interconnected with a 1 GbE (Gigabit Ethernet) switch, and these three rack-level switch should be interconnected with a cluster level switch which is typically faster (for example a 10 GbE switch).</p>

<p>This is only a starting point! The remaining hardware choices may vary a lot&#8230; I can recommend you to read the Cluster Planning Guide of <a href="http://hortonworks.com">Hortonworks</a>.</p>

<h2>Install an Apache Hadoop Distribution</h2>

<p>Apache Hadoop and all its friends can be installed manually on a Linux distribution by following the official <a href="https://hadoop.apache.org/docs/current2/index.html">guide</a>, but it is strongly suggested to instal an Hadoop distribution: At the moment the commercial <a href="http://www.cloudera.com">Cloudera CDH</a> seems to be a good choise. It is a Linux distribution based on the stable CentOS (Red Hat) and it has pre-installed all the utilities used in an Hadoop cluster.</p>

<p>Another distribution, 100% open source and freely downloadable, is <a href="http://hortonworks.com">Hortonworks Data Platform</a>: this distribution is lightweight and can be used with Microsoft Windows too.</p>

<p>There are many other Apache Hadoop distributions, for example <a href="http://www.ibm.com/big-data/us/en/">IBM Appliances</a> and <a href="http://www.windowsazure.com/en-us/services/hdinsight/">Microsoft HDInsight Service</a>: you only have to choose and try.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A GIT Branching Model for Medium-size Companies]]></title>
    <link href="http://fsferrara.github.io/git-branching-model-for-medium-size-companies/"/>
    <updated>2013-11-15T00:13:57+00:00</updated>
    <id>http://fsferrara.github.io/git-branching-model-for-medium-size-companies</id>
    <content type="html"><![CDATA[<p>This article explains how a medium size company, which has several teams, can adopt GIT for the source code management. As a software configuration management, GIT serves two different functions. The first one is the management support for controlling changes to software products, and the second one is merely development support for coordinating file changes among product developers. In particular here I want to talk about the branching model.</p>

<!--more-->


<p>The following branching model is for a single product, whereas only the last product version is maintained (i.e. a web site or a mobile app). Additionally this branching model support an agile process model, where a new product version is released (hopefully) at the end of each team sprint.</p>

<p>This proposal is based on the &#8220;branch-by-purpose&#8221; model (@see <a href="http://svn.haxx.se/users/archive-2007-10/att-0101/SCMBranchingModels.pdf">The Importance of Branching Models in SCM</a>), but it also provide a branch for the next release.</p>

<p>Main actors here are:</p>

<ul>
<li><strong>Developers</strong>, one or more developer teams</li>
<li><strong>Release manager</strong>, or a release team</li>
<li><strong>System administrator</strong>, or a sysadm team</li>
</ul>


<p>This branching model is inspired by the work of <a href="http://nvie.com/about/">Vincent Driessen</a>.</p>

<h2>Branches organization</h2>

<p>A good branching model for medium-size technology department should absolutely have these characteristics:</p>

<ul>
<li>Parallel Development</li>
<li>Collaboration</li>
<li>Release Staging</li>
<li>Support for emergency fixes (hotfix)</li>
</ul>


<p>The proposed branching model has three branches, each with an infinite life. System administrators will always use the &#8216;master&#8217; branch: everything is happy and deployable in master. Developers should always use the &#8216;develop&#8217; branch, and all teams share this branch to commit their features. Also developers can&#8217;t commit anything in the master branch, the release manager is in charge of this operation. The release manager has its own branch &#8216;candidate&#8217; in order to integrate in it the team&#8217;s patches, test these patches, promote versions, and then commit stable versions in the &#8216;master&#8217; branch. The original work <a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> does not have the &#8216;candidate&#8217; branch, but uses a new branch for each release. I, instead, prefer to have the integration branch always with the same name: this can be useful in the future for the dependencies management.</p>

<h2>Creating the three branches</h2>

<p>Once created the repository with the master branch, you can create &#8216;candidate&#8217; and &#8216;develop&#8217; branches.</p>

<pre lang="bash">[~/git]$ git clone https://github.com/fsferrara/lemon.git
Cloning into 'lemon'...
remote: Counting objects: 12, done.
remote: Compressing objects: 100% (11/11), done.
remote: Total 12 (delta 2), reused 10 (delta 0)
Unpacking objects: 100% (12/12), done.
[~/git]$ cd lemon

[master][~/git/lemon]$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master

[master][~/git/lemon]$ git branch candidate master
[master][~/git/lemon]$ git branch develop candidate

[master][~/git/lemon]$ git push origin candidate
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new branch]      candidate -&gt; candidate

[master][~/git/lemon]$ git push origin develop
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new branch]      develop -&gt; develop</pre>


<p>Now we have these branches:<figure id="attachment_314" style="max-width: 250px" class="wp-caption aligncenter"></p>

<p><a href="http://www.fsferrara.com/wp-content/uploads/2013/11/00_three_branches.jpg"><img class="size-medium wp-image-314" src="http://www.fsferrara.com/wp-content/uploads/2013/11/00_three_branches-250x300.jpg" alt="Three Branches" width="250" height="300" srcset="http://www.fsferrara.com/wp-content/uploads/2013/11/00_three_branches-250x300.jpg 250w, http://www.fsferrara.com/wp-content/uploads/2013/11/00_three_branches.jpg 409w" sizes="(max-width: 250px) 100vw, 250px" /></a><figcaption class="wp-caption-text">Three Branches</figcaption></figure></p>

<h2>The features</h2>

<p>Any new feature should be developed in a separate branch. So, a developer that is on &#8216;develop&#8217; branch&#8230;</p>

<pre lang="bash">[master][~/git/lemon]$ git checkout develop
Switched to branch 'develop'
[develop][~/git/lemon]$ git branch -a
  candidate
* develop
  master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/candidate
  remotes/origin/develop
  remotes/origin/master</pre>


<p>&#8230;must start a feature branch, and share it with its team:</p>

<pre lang="bash">[develop][~/git/lemon]$ git checkout -b myteam/amazing_feature
Switched to a new branch 'myteam/amazing_feature'

[myteam/amazing_feature][~/git/lemon]$ git push origin myteam/amazing_feature
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new branch]      myteam/amazing_feature -&gt; myteam/amazing_feature</pre>


<p>Rebasing keeps our code working, merging easy, and history clean. Developer should maintain this branch always rebased with remote branches &#8216;origin/devel&#8217; and &#8216;origin/myteam/amazing_feature&#8217;, by doing these operations:</p>

<pre lang="bash">[myteam/amazing_feature][~/git/lemon]$ git fetch origin
[develop][~/git/lemon]$ git rebase origin/develop
Current branch develop is up to date.
[develop][~/git/lemon]$ git rebase origin/myteam/amazing_feature
Current branch develop is up to date.</pre>


<p>The branch &#8216;myteam/amazing_feature&#8217; contains all the feature commits. These commit should not be done directly on the &#8216;develop&#8217; branch because anything committed to this branch can be delivered on-line without any notice. Once the feature is done, the feature branch is reintegrated in the &#8216;develop&#8217; branch.<figure id="attachment_315" style="max-width: 145px" class="wp-caption aligncenter"></p>

<p><a href="http://www.fsferrara.com/wp-content/uploads/2013/11/01_feature_branch.jpg"><img class="size-medium wp-image-315" src="http://www.fsferrara.com/wp-content/uploads/2013/11/01_feature_branch-145x300.jpg" alt="Feature Branch" width="145" height="300" srcset="http://www.fsferrara.com/wp-content/uploads/2013/11/01_feature_branch-145x300.jpg 145w, http://www.fsferrara.com/wp-content/uploads/2013/11/01_feature_branch.jpg 235w" sizes="(max-width: 145px) 100vw, 145px" /></a><figcaption class="wp-caption-text">Feature Branch</figcaption></figure></p>

<p>At this point a &#8220;merge request&#8221; can be created also to manage the code review process. To finish a feature, perform these operations:</p>

<pre lang="bash">[myteam/amazing_feature][~/git/lemon]$ git fetch
[myteam/amazing_feature][~/git/lemon]$ git rebase -i origin/develop
Successfully rebased and updated refs/heads/myteam/amazing_feature.

[master][~/git/lemon]$ git checkout develop
Switched to branch 'develop'

[develop][~/git/lemon]$ git fetch
[develop][~/git/lemon]$ git merge origin/develop
Already up-to-date.

[develop][~/git/lemon]$ git merge --no-ff myteam/amazing_feature
Merge made by the 'recursive' strategy.
 hello.js | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

[develop][~/git/lemon]$ git push origin develop
Counting objects: 1, done.
Writing objects: 100% (1/1), 241 bytes, done.
Total 1 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
   cd84dc7..ee499c9  develop -&gt; develop</pre>


<p>The option &#8220;&#8211;no-ff&#8221; preserves feature history and easy full-feature reverts merge. Now we can delete the feature branch:</p>

<pre lang="bash">[develop][~/git/lemon]$ git branch -d myteam/amazing_feature
Deleted branch myteam/amazing_feature (was a30b140).

[develop][~/git/lemon]$ git push --delete origin myteam/amazing_feature
To https://github.com/fsferrara/lemon.git
 - [deleted]         myteam/amazing_feature</pre>


<h2>Integration phase and release</h2>

<p>At any time the release engineer can merge the new content of &#8216;devel&#8217; and start an integration phase, as this picture show:<figure id="attachment_316" style="max-width: 260px" class="wp-caption aligncenter"></p>

<p><a href="http://www.fsferrara.com/wp-content/uploads/2013/11/02_candidate_branch.jpg"><img class="size-medium wp-image-316" src="http://www.fsferrara.com/wp-content/uploads/2013/11/02_candidate_branch-260x300.jpg" alt="Candidate Branch" width="260" height="300" srcset="http://www.fsferrara.com/wp-content/uploads/2013/11/02_candidate_branch-260x300.jpg 260w, http://www.fsferrara.com/wp-content/uploads/2013/11/02_candidate_branch.jpg 412w" sizes="(max-width: 260px) 100vw, 260px" /></a><figcaption class="wp-caption-text">Candidate Branch</figcaption></figure></p>

<p>The integration starts with the <em>code chill</em> phase, that is the phase in which only small bugfixes are allowed. Personally I hate these bugfixes, and I prefer to perform all kind of tests directly on &#8216;devel&#8217; branch: for me the integration phase should be only the final check. Once the code is ready to be deployed in production, we have the reintegration with &#8216;master&#8217;. At this point the release engineer can create the tag directly on master. Optionally the tag to be created can point before to the head of &#8216;candidate&#8217; branch and then can be updated to point to &#8216;master&#8217;.</p>

<h2>Deploying and emergency fixes</h2>

<p>Everything is happy and up-to-date in master: the system administrator can use tags created by the release engineer to deploy a specific version of the product. This support the deploy of the latest version and also the roll-back to a previous version. Once reintegrated the branch &#8216;candidate&#8217; into &#8216;master&#8217;, a new tag is created following these steps:</p>

<pre lang="bash">[master][~/git/lemon]$ git tag -a 1.2.3 -m "Promoted on `date`"
[master][~/git/lemon]$ git tag -l
1.2.3

[master][~/git/lemon]$ git push --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 182 bytes, done.
Total 1 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new tag]         1.2.3 -&gt; 1.2.3

[master][~/git/lemon]$ git ls-remote --tags origin
83fd280e796bc4134c2e7b31106b9f8ed85ecf2c    refs/tags/1.2.3
cd84dc74b39607706e8f1b110411b4a508c6f3e8    refs/tags/1.2.3^{}</pre>


<p>If for testing purpose you already created the tag 1.2.3 pointing the &#8216;candidate&#8217; branch, now you can move this tag by using the option &#8220;-f&#8221;.</p>

<p>Also the emergency bug fixes (hotfix) are supported by this model, as shown in this picture:<figure id="attachment_317" style="max-width: 190px" class="wp-caption aligncenter"></p>

<p><a href="http://www.fsferrara.com/wp-content/uploads/2013/11/03_hotfix.jpg"><img class="size-medium wp-image-317" src="http://www.fsferrara.com/wp-content/uploads/2013/11/03_hotfix-190x300.jpg" alt="Hotfix Branch" width="190" height="300" srcset="http://www.fsferrara.com/wp-content/uploads/2013/11/03_hotfix-190x300.jpg 190w, http://www.fsferrara.com/wp-content/uploads/2013/11/03_hotfix.jpg 312w" sizes="(max-width: 190px) 100vw, 190px" /></a><figcaption class="wp-caption-text">Hotfix Branch</figcaption></figure></p>

<h2>Useful configuration</h2>

<p>Autosetup rebase so that pulls operations rebase by default</p>

<pre lang="bash">git config --global branch.autosetuprebase always</pre>


<h2>DOs and DON&#8217;Ts</h2>

<p>No DO or DON&#8217;T is sacred. You&#8217;ll obviously run into exceptions, and develop your own way of doing things. However, these are guidelines I&#8217;ve found useful.</p>

<h3>DOs</h3>

<ul>
<li><em>do</em> master must always be deployable.</li>
<li><em>do</em> all changes are made through feature branches</li>
<li><em>do</em> use a &#8220;merge request&#8221; (aka &#8220;pull request&#8221;) to manage code-reviews</li>
<li><em>do</em> rebase to avoid/resolve conflicts before to merge</li>
<li><em>do</em> keep master in working order</li>
<li><em>do</em> rebase your feature branches often</li>
<li><em>do</em> tag releases</li>
<li><em>do</em> learn to rebase and merge</li>
</ul>


<h3>DON&#8217;Ts</h3>

<ul>
<li><em>don&#8217;t</em> fork</li>
<li><em>don&#8217;t</em> merge broken code.</li>
<li><em>don&#8217;t</em> commit onto master directly.</li>
<li><em>don&#8217;t</em> hotfix onto master! use a specific hotfix branch.</li>
<li><em>don&#8217;t</em> rebase master.</li>
<li><em>don&#8217;t</em> merge with conflicts. Handle conflicts upon rebasing.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GIT Explained for Subversion Users]]></title>
    <link href="http://fsferrara.github.io/git-explained-subversion-users/"/>
    <updated>2013-11-03T23:31:45+00:00</updated>
    <id>http://fsferrara.github.io/git-explained-subversion-users</id>
    <content type="html"><![CDATA[<p><code>This guide shows the most common procedures usually performed by SVN users, but using GIT.&lt;br /&gt;
Why this guide should be better than the others already on-line? There isn't a particular reason ;) . I'm now a SVN user and I'm just migrating to GIT, so I'm going to find a way to perform with GIT all the operations that I usually do with Subversion: this will be useful for Subversion users who want to start using GIT quickly.</code></p>

<!--more-->


<p>Git is a distributed revision control (DVCS) and source code management (SCM) system with an emphasis on speed. As a distributed VCS, every Git working directory is a full-fledged repository with complete history and full version tracking capabilities, not dependent on network access or a central server.</p>

<p>This is the most substantial difference with SVN where there is a central repository. With subversion, the developers working in a team used continuously exchange their code. This is deeply different with GIT because there is no a main central repository; so developer should use a given remote repository, and use it as the central one.</p>

<p>No more talk, I don&#8217;t like to talk: let&#8217;s start with GIT by examples.</p>

<p>We have two developers, obviously their user-names are Alice and Bob.</p>

<h2>GIT &#8211; Create a repository</h2>

<p>Alice wants to create a new project named &#8220;lemon&#8221;. She simply creates an empty directory and then launch the command &#8216;git init&#8217;:</p>

<pre lang="bash">[~/alice]$ mkdir lemon
[~/alice]$ cd lemon
[~/alice/lemon]$ git init
Initialized empty Git repository in /Users/fferrara/alice/lemon/.git/
[master][~/alice/lemon]$
</pre>


<p>That&#8217;s all! Alice has now a brand new repository locally (note that this is more than a working copy). The main branch is called &#8220;master&#8221;. The shell prompt has the capability to detect and print the name of the current branch (this is the zsh shell default behaviour).</p>

<h2>GIT &#8211; Your first commit</h2>

<p>Let&#8217;s prepare our first file commit. Lemon has one simple file &#8216;hello.js&#8217; containing the source code.</p>

<pre lang="javascript">var prompt = require('prompt');

prompt.start();

prompt.get(['fruit'], function(err, result) {

    if (result) {
        console.log('Hey fruit ' + result.fruit);
        if ('lemon' == result.fruit) {
            console.log('I like yellow things :) ');
        };
    }
});</pre>


<p>Also we have a package.json configuration file.</p>

<pre lang="javascript">{
  "dependencies": {
    "prompt": "0.2.11"
  }
}
</pre>


<p>As many of you know, in this type of application, we have to ignore the node_modules directory. So we have to create the .gitignore file containing the ignore-list.</p>

<pre lang="bash">*[master][~/alice/lemon]$ echo "node_modules" &gt; .gitignore
</pre>


<p>To see the status of our branch, you should use the command &#8216;git status&#8217;</p>

<pre lang="bash">*[master][~/alice/lemon]$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add ..." to include in what will be committed)
#
#   .gitignore
#   hello.js
#   package.json
nothing added to commit but untracked files present (use "git add" to track)
</pre>


<p>The file for now are all in the &#8216;untracked&#8217; status, that is the first state. To track these files we have to add them to the repository index.</p>

<pre lang="bash">*[master][~/alice/lemon]$ git add .gitignore package.json hello.js
</pre>


<p>Check the status again</p>

<pre lang="bash">*[master][~/alice/lemon]$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached ..." to unstage)
#
#   new file:   .gitignore
#   new file:   hello.js
#   new file:   package.json
#
</pre>


<p>The added files are now ready to be committed (aka tracked-file). The commit command resembles that of SVN.</p>

<pre lang="bash">*[master][~/alice/lemon]$ git commit -m "my first git commit"
[master (root-commit) 7046414] my first git commit
 3 files changed, 19 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 hello.js
 create mode 100644 package.json
</pre>


<p>Note that the number &#8216;7046414&#8217; is equivalent of the SVN revision number. Actually it is a commit hash and in this context is truncated to the first 7 characters. To see the entire commit identified we can print the commit log.</p>

<p>Use the &#8216;git log&#8217; command to see this:</p>

<pre lang="bash">commit 7046414d2c9d3407f421987449c92877718248f9
Author: alice
Date:   Fri Nov 1 16:44:31 2013 +0100
     my first git commit
(END)
</pre>


<h2>GIT &#8211; Share your commit with the team</h2>

<p>What about the remote repository? Actually GIT doesn&#8217;t need a main remote repository, but can track several distributed repositories.</p>

<p>For this example I&#8217;m borrowing to Alice this remote <a href="https://github.com/fsferrara/lemon.git">https://github.com/fsferrara/lemon.git</a> repository. She should set this uri in her local repository, and then verify with the command &#8216;git remote -v&#8217;.</p>

<pre lang="bash">[master][~/alice/lemon]$ git remote -v
[master][~/alice/lemon]$ git remote add origin https://github.com/fsferrara/lemon.git
[master][~/alice/lemon]$ git remote -v
origin  https://github.com/fsferrara/lemon.git (fetch)
origin  https://github.com/fsferrara/lemon.git (push)
</pre>


<p>Nice&#8230; a remote (by default called &#8216;origin&#8217;) to share our branch!</p>

<p>Yes, you&#8217;ve got it right. With GIT we always share branches. Alice now have to push her master branch to the origin repository.</p>

<pre lang="bash">[master][~/alice/lemon]$ git push -u origin master
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (5/5), 514 bytes, done.
Total 5 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from origin.
</pre>


<p>In a team, were developer used to often share their code with SVN, this operation should be performed after every commit.</p>

<p>Only the first time we share a branch we should use the -u flag, in order to set the upstream. In a nutshell an upstream is a tracking reference, in order to set Alice&#8217;s master branch to track the remote master branch (we can refer to it as origin/master or remotes/origin/master).</p>

<p>The &#8216;git branch -a&#8217; command prints out the entire lists of branches.</p>

<pre lang="bash">[master][~/alice/lemon]$ git branch -a
* master
  remotes/origin/master
</pre>


<h2>GIT &#8211; Create a branch</h2>

<p>Now Alice want to write down a killer feature&#8230; maybe it can be a custom message not only for lemons, but also for all kinds of citrus fruit. The first thing to do is to create a branch&#8230;</p>

<pre lang="bash">[master][~/alice/lemon]$ git branch citrus
[master][~/alice/lemon]$ git branch -a
  citrus
* master
  remotes/origin/master
</pre>


<p>The branch citrus is created only locally. That means that the origin (aka remote repository) doesn&#8217;t have this branch. Alice can share this branch with others by pushing it to origin.</p>

<pre lang="bash">[master][~/alice/lemon]$ git push -u origin citrus
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new branch]      citrus -&gt; citrus
Branch citrus set up to track remote branch citrus from origin.
[master][~/alice/lemon]$ git branch -a
  citrus
* master
  remotes/origin/citrus
  remotes/origin/master
</pre>


<h2>GIT &#8211; Switch to a branch</h2>

<p>But Alice can&#8217;t start working because is still using the master branch. The &#8216;git checkout&#8217; command is launched to change the current branch.</p>

<p>Yes poor SVN users&#8230; with GIT the checkout command doesn&#8217;t means &#8216;create a brand new working copy&#8217;, but has now a new meaning: now checkout is used to switch branch or revert a modified file or directory.</p>

<p>Let&#8217;s start by simply change the current branch:</p>

<pre lang="bash">[master][~/alice/lemon]$ git checkout citrus
Switched to branch 'citrus'
[citrus][~/alice/lemon]$ git branch -a
* citrus
  master
  remotes/origin/citrus
  remotes/origin/master
</pre>


<h2>GIT &#8211; Clone an existing repository</h2>

<p>Bob, a team mate of Alice, awakens, and start working at the project lemon. The first thing is to clone an existing repository by using the given uri.</p>

<pre lang="bash">[~/bob]$ git clone https://github.com/fsferrara/lemon.git lemon
Cloning into 'lemon'...
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 5 (delta 0), reused 5 (delta 0)
Unpacking objects: 100% (5/5), done.
[~/bob]$ cd lemon
[master][~/bob/lemon]$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/citrus
  remotes/origin/master
</pre>


<h2>GIT &#8211; Share a commit on an existing file</h2>

<p>Ops&#8230; there is a minor bug! The &#8216;hello&#8217; string doesn&#8217;t contains the point. Bob choose to treat it as a hot bugfix, and to commit this change directly on the master branch.</p>

<p>He first edit the hello.js file, and then:</p>

<pre lang="bash">*[master][~/bob/lemon]$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add ..." to update what will be committed)
#   (use "git checkout -- ..." to discard changes in working directory)
#
#   modified:   hello.js
#
no changes added to commit (use "git add" and/or "git commit -a")
*[master][~/bob/lemon]$ git add hello.js
*[master][~/bob/lemon]$ git commit -m "hot bugfix"
[master c6538cc] hot bugfix
 1 file changed, 1 insertion(+), 1 deletion(-)
[master][~/bob/lemon]$ git push origin master
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 346 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
   7046414..c6538cc  master -&gt; master
[master][~/bob/lemon]$
</pre>


<h2>GIT &#8211; Create a tag</h2>

<p>Bob want to freeze the current master version to a given tag. We&#8217;re familiar with tags since we currently are SVN users :) but in the GIT case there isn&#8217;t a folder that contains all the tag. Tags are treated like commits, and refers to a snapshot of the source code.</p>

<p>The &#8216;git tag&#8217; command is used here. After the tag is created, there is need to push it in order to share it with the team.</p>

<pre lang="bash">[master][~/bob/lemon]$ git tag -l
[master][~/bob/lemon]$ git tag -a v0.1.0 -m "Released on `date`"
[master][~/bob/lemon]$ git tag -l
v0.1.0
[master][~/bob/lemon]$ git push --tags origin master
Counting objects: 1, done.
Writing objects: 100% (1/1), 184 bytes, done.
Total 1 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
 * [new tag]         v0.1.0 -&gt; v0.1.0
</pre>


<h2>GIT &#8211; Check if a branch is rebased</h2>

<p>Alice is working on branch &#8216;citrus&#8217; and in the meanwhile Bob committed a fix on the master branch. How Alice can check if the branch she is currently working on has to be rebased? The first thing to do is to &#8216;fetch&#8217; updates from origin.</p>

<pre lang="bash">[citrus][~/alice/lemon]$ git fetch
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 1), reused 4 (delta 1)
Unpacking objects: 100% (4/4), done.
From https://github.com/fsferrara/lemon
   7046414..c6538cc  master     -&gt; origin/master
 * [new tag]         v0.1.0     -&gt; v0.1.0
</pre>


<p>Now Alice&#8217;s repository has information about Bob&#8217;s commits and tags. In order to know if the current branch is rebased with master Alice can use the &#8216;git cherry&#8217; command. Another option are the more powerful commands:</p>

<p>gitk citrus..origin/master</p>

<p>git log citrus..origin/master</p>

<p>The range notation &#8220;citrus..master&#8221; means &#8220;show everything that is included in master but is not included in citrus&#8221;.</p>

<pre lang="bash">[citrus][~/alice/lemon]$ git cherry citrus origin/master
+ c6538cc3b3fed65bd5c9cfe708961f1f5f2e1616</pre>


<h2>GIT &#8211; Rebase a branch with master</h2>

<p>Expected surprise! There is a commit (c6538cc3b3fed65bd5c9cfe708961f1f5f2e1616) not included in the current branch. Now is very important to note all the branches present in Alice&#8217;s repository:</p>

<pre lang="bash">[citrus][~/alice/lemon]$ git branch -a
* citrus
  master
  remotes/origin/citrus
  remotes/origin/master
</pre>


<p>There are two local branches (citrus and master), and two remote tracked branches (origin/citrus and origin/master). At the moment origin/master is updated, but master isn&#8217;t updated yet. That&#8217;s because &#8216;git fetch&#8217; only download new information but doesn&#8217;t perform any merge operation.</p>

<p>The choice is to work with remote branches, or update local branches and work with locals. Alice choose to work with the remote ones.</p>

<pre lang="bash">[citrus][~/alice/lemon]$ git rebase origin/master citrus
First, rewinding head to replay your work on top of it...
Fast-forwarded citrus to origin/master.
[citrus][~/alice/lemon]$ git status
# On branch citrus
# Your branch is ahead of 'origin/citrus' by 1 commit.
#
nothing to commit (working directory clean)
[citrus][~/alice/lemon]$ git push origin citrus
Total 0 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
   7046414..c6538cc  citrus -&gt; citrus
[citrus][~/alice/lemon]$ git status
# On branch citrus
nothing to commit (working directory clean)
</pre>


<p>Examining the log (with git log or gitk) we can see that now citrus and origin/citrus branches have exactly the commit c6538cc3b3fed65bd5c9cfe708961f1f5f2e1616 in their log. That means that this commit is now in common with the master branch.</p>

<h2>GIT &#8211; Reintegrate a branch</h2>

<p>Alice worked hard on her branch, and a the end commits the killer feature.</p>

<pre lang="bash">[citrus][~/alice/lemon]$ vim hello.js
*[citrus][~/alice/lemon]$ git add hello.js
*[citrus][~/alice/lemon]$ git commit -m "Add the killer feature"
[citrus b306b5c] Add the killer feature
 1 file changed, 3 insertions(+)
[citrus][~/alice/lemon]$ git push origin citrus
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 447 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
   c6538cc..b306b5c  citrus -&gt; citrus
</pre>


<p>Ops&#8230; she forgot something :( . Another commit is necessary:</p>

<pre lang="bash">[citrus][~/alice/lemon]$ vim hello.js
*[citrus][~/alice/lemon]$ git add hello.js
*[citrus][~/alice/lemon]$ git commit -m "This actually add the killer feature"
[citrus ae073c3] This actually add the killer feature
 1 file changed, 3 insertions(+)
[citrus][~/alice/lemon]$ git push origin citrus
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 370 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
   b306b5c..ae073c3  citrus -&gt; citrus
</pre>


<p>Bob wants now to integrate Alice&#8217;s commits in the master branch. So the first thing to do is to fetch the updates.</p>

<pre lang="bash">[master][~/bob/lemon]$ git fetch
remote: Counting objects: 8, done.
remote: Compressing objects: 100% (5/5), done.
remote: Total 6 (delta 2), reused 5 (delta 1)
Unpacking objects: 100% (6/6), done.
From https://github.com/fsferrara/lemon
   7046414..ae073c3  citrus     -&gt; origin/citrus
</pre>


<p>Now Bob has to merge all the Alice&#8217;s commit in the master branch. The following command &#8216;squash&#8217; these commits into one commit, and add the change-set to the GIT index:</p>

<pre lang="bash">[master][~/bob/lemon]$ git merge --squash origin/citrus
Updating c6538cc..ae073c3
Fast-forward
Squash commit -- not updating HEAD
 hello.js | 6 ++++++
 1 file changed, 6 insertions(+)
</pre>


<p>The working branch of Bob now has all the changes introduced by Alice. To see the difference Bob should use the command &#8216;git diff &#8211;staged&#8217;.</p>

<p>Finally to reintegrate the branch:</p>

<pre lang="bash">*[master][~/bob/lemon]$ git commit -m "Reintegrate branch citrus into master"
[master cd84dc7] Reintegrate branch citrus into master
 1 file changed, 6 insertions(+)
[master][~/bob/lemon]$ git push origin master
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 538 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/fsferrara/lemon.git
   c6538cc..cd84dc7  master -&gt; master
</pre>


<h2>GIT &#8211; Delete a branch</h2>

<p>At the end Bob can delete the branch he previously integrated on master. The &#8216;git branch -d&#8217; command is used.</p>

<pre lang="bash">[master][~/bob/lemon]$ git branch -d citrus
warning: deleting branch 'citrus' that has been merged to
 'refs/remotes/origin/citrus', but not yet merged to HEAD.
Deleted branch citrus (was ae073c3).
[master][~/bob/lemon]$ git push --delete origin citrus
To https://github.com/fsferrara/lemon.git
 - [deleted]         citrus
</pre>


<p>Note that the command &#8216;git branch -d&#8217; ensures that the changes in the citrus branch are already in the current branch. If not, you should use the option -D instead.</p>

<h2>What&#8217;s next&#8230;</h2>

<p>Time is over :/ . Next operation I usually perform with SVN are:</p>

<ul>
<li>GIT &#8211; Return to a revision</li>
<li>GIT &#8211; Return to a tag</li>
<li>GIT &#8211; Reverse merge</li>
<li>GIT &#8211; Undo a wrong commit (or a list&#8230; remeber the order)</li>
<li>GIT &#8211; Create a diff-file and perform a patch</li>
<li>GIT &#8211; Stash</li>
<li>GIT &#8211; Export</li>
</ul>


<p>Asap I&#8217;ll write about these operation. In the meanwhile I suggest you these manual page: &#8216;man gittutorial&#8217; and the very interesting &#8216;man gittutorial-2&#8217;</p>

<p>Goodbye and happy versioning :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ISDN Technology]]></title>
    <link href="http://fsferrara.github.io/isdn-technology/"/>
    <updated>2010-01-09T01:28:47+00:00</updated>
    <id>http://fsferrara.github.io/isdn-technology</id>
    <content type="html"><![CDATA[<p>Integrated Services Digital Network, o ISDN, è una rete digitale che dà supporto a molti servizi di voce e dati. La definizione tecnica dell&#8217;ISDN, che investe diverse componenti delle reti, risale alle raccomandazioni ITU-T della serie I del 1984 e comprende numerose altre pubblicazioni dello stesso ITU-T e dell&#8217;ETSI (European Telecommunications Standard Institute) fatte negli anni successivi.</p>

<!--more-->


<h2>**Integrated Services Digital Network &#8211; ISDN</h2>

<p>**</p>

<p>ISDN è un servizio di <em>telefonia digitale</em> basato sul protocollo ISDN. Quindi con il termine ISDN ci riferiamo sia al protocollo, sia al servizio implementato dal protocollo stesso.</p>

<p>ISDN: protocollo che descrive come si svolgono le chiamate</p>

<p>Una rete ISDN è quindi una rete digitale anche integrata nei servizi, in cui le diverse parti, il terminale, la rete di accesso, la rete di trasporto, sono realizzate per offrire gli stessi servizi. Elementi fondamentali per il supporto di tali servizi sono il protocollo di segnalazione della rete di trasporto ISUP (ITU-T Q.767) e della rete di accesso DSS1 (ITU-T Q.931), che fanno parte della pila di protocolli del sistema di segnalazione a canale comune n°7 insieme ad altri descritti nelle Racc. ITU-T serie Q. Attraverso tali protocolli vengono trasportate le informazioni che consentono l&#8217;espletamento dei diversi servizi; un esempio per tutti l&#8217;identità del chiamante, che viene trasportata dai protocolli di segnalazione dalla rete del chiamante verso la rete e il terminale del chiamato.</p>

<p>In Europa è usata la variante ISDN-DSS1 sviluppata da ETSI (European Telecomunications Standards Institute).</p>

<p>Sull&#8217;accesso BRA ISDN sono disponibili una serie di nuovi servizi come la segnalazione del numero telefonico di chi chiama (Caller ID) e il multinumero, cioè la possibilità di avere fino ad otto numeri telefonici sullo stesso abbonamento, ciascuno assegnato ad un apparecchio diverso (es. uno per il telefono, uno per il fax, uno per il modem in ingresso&#8230;). La tecnologia digitale utilizzata da ISDN garantisce una qualità audio molto elevata, eliminando completamente la diafonia e buona parte dei disturbi presenti nella tradizionale telefonia . In Italia ISDN BRA viene fornito in modalità mononumero o multinumero: è possibile cioè richiedere fino a 7 numeri telefonici diversi oltre al numero principale. Sempre sull&#8217;accesso base (BRA), che comprende 2 canali B a 64 Kbit/sec, è possibile collegarsi ad Internet sia ad una velocità di 64 Kbit/s, pagando una semplice telefonata, sia, se il Provider utilizzato lo permette, ad una velocità di 128 Kbit/s, sostenendo però il costo di due chiamate contemporanee. Inoltre sono disponibili i servizi di avviso di chiamata, conferenza a tre, presentazione dell&#8217;identità del chiamante (Caller ID), trasferimento di chiamata e per alcuni Operatori anche il servizio di richiamata su occupato.</p>

<p>Molto diffusa in Italia un tipo particolare di NT, chiamata NT1+, che ha al suo interno anche un Terminal Adapter (TA) a/b, capace di gestire due porte analogiche, permettendo cosi&#8217; di connettere direttamente all&#8217;NT1+ apparati analogici come telefoni tradizionali o fax di gruppo 3. L&#8217;installazione della borchia ISDN deve essere richiesta al proprietario della rete.</p>

<p>Una ulteriore configurazione degli accessi è il &#8220;punto-punto&#8221; e &#8220;punto-multipunto&#8221; che in buona sostanza esprime il modo di dialogare della rete con uno o più terminali lato utente. La configurazione &#8220;punto-punto&#8221; è adottata in presenza, lato utente, di centralini (PABX)collegati sia su accesso primario che in pool di accessi base. La configurazione punto-multipunto è adottata ad esempio negli accessi base in cui sul bus isdn sono collegati dispositivi con numeri diversi (MSN) quali telefoni isdn, modem isdn, fax G4. La differenza tecnica che contraddistingue anche le due tipologie è il cosiddetto TEI, che viene utilizzato nel protocollo ISDN, per il quale una punto-punto è fisso a zero, mentre sulla punto-multipunto è variabile e deciso dalla centrale pubblica. Per capire se la tipologia e punto-punto o punto-multipunto, soprattutto nel caso di accesso base mononumero, bisogna contattare l&#8217;operatore che fornisce il servizio, non esistono veri e propri standard.</p>

<p><strong><span style="text-decoration: underline;">CALLER-ID</span>:</strong> è la funzione che ci permette di vedere il numero di chi ci chiama.</p>

<p><strong><span style="text-decoration: underline;">MULTINUMERO</span>:</strong> Possibilità di avere fino a 8 numeri su una singola linea ISDN. Ovviamente bisognerà assegnare un numero per ogni apparecchio.</p>

<p>Il collegamento ISDN più diffuso è quello base, a due canali (detto BRI):</p>

<ul>
<li>1° Canale: 64 kbit/s</li>
<li>2° Canale: 64 kbit/s</li>
<li>3° Canale aggiuntivo: 16 kbit/s (usato per le segnalazioni)</li>
</ul>


<p>La banda totale e&#8217; 144 kbit/s!!! Di questa banda, solo i canali da 64 kbit/s sono sfruttati per trasferire informazioni utili all&#8217;utente finale, quindi in effetti l&#8217;utente beneficia di 128 kbit/s (sempre teorici)</p>

<h2>Architettura ISDN</h2>

<h3>Alcuni termini</h3>

<ul>
<li><strong>NT (Network Terminator)</strong>: Traduce il segnale proveniente dalla centrale telefonica, mediante <em>U-BUS</em>, in segnale utilizzabile dai nostri dispositivi ISDN, su <em>S-BUS</em>. Inoltre il Network Terminator permette di attaccarci</li>
<li><strong>TA (Terminal Adapter)</strong> : Permette di allacciare vecchi dispositivi analogigi al Network Terminator, in moda da poterli riutilizzare. E&#8217; indicato per i vecchi FAX ;-) .</li>
</ul>


<h3>Esempio NT (Network Terminator)</h3>

<p>Un Network Terminator, che prende in ingresso un U-Bus dalla linea ISDN, e caccia in output due S-Bus per allacciarci due dispositivi ISDN (ad esempio due telefono ISDN).</p>

<p>Notiamo che in S-Bus non è che un cavo ethernet, usato per ISDN&#8230; e (forse) per U-Bus si usa il doppino telefonico, o anche in questo caso un cavo ethernet.</p>

<h2>Configurazione di ISDN</h2>

<p>Una linea ISDN può avere varie configurazioni, in modo da adattarsi all&#8217;hardware con il quale deve funzionare (esempio PBX &#8211; centralino telefonico).</p>

<h3>Canali</h3>

<p>ISDN supporta due tipi di canali:</p>

<p><strong>-> Canale B</strong> (Bearer): sono canali utilizzati per i dati ed hanno una banda prefissata di 64 kbit/s.</p>

<p><strong>-> Canale D</strong> (Delta): sono canali usati per segnalazioni e controllo; in particolari configurazioni possono essere usati anche per i dati. La banda passante assegnata ad un canale D varia al variare del tipo di <em>Accesso ISDN</em>.</p>

<h3>Accesso ISDN</h3>

<p>Esistono due tipi di accesso ISDN:</p>

<ul>
<li><strong>Accesso BRI [Basic Rate Interface &#8211; Accesso Base]</strong>:&#8211; 2 canali B&#8211; 1 canale D a 16 kbit/s==> Totale 2B+D = 144 kbit/s</li>
<li><strong>Accesso PRI T1 [Basic Rate Interface &#8211; Accesso Base]</strong>: (America, Giappone)&#8211; 23 canali B&#8211; 1 canale D a 64 kbit/s==> Totale 23B+D = 1536 kbit/s</li>
<li><strong>Accesso BRI E1 [Basic Rate Interface &#8211; Accesso Base]</strong>: (Europa, Asia, Australia)&#8211; 30 canali B&#8211; 2 canale D a 64 kbit/s==> Totale 30B+2D = 2048 kbit/s</li>
</ul>


<h3>Funzionamento Chiamate</h3>

<p>I canali D sono usati per <em>iniziare</em> le chiamate. Una volta che la chiamata è iniziata, ad essa è allocato un canale B&#8230; quindi per ogni chiamata deve essere disponibile un canale B (sempre di 64 kbit/s).</p>

<p>Notiamo come i canali B sono allocati sempre in modo dinamico!</p>

<h2>Considerazioni Tecniche</h2>

<p>L&#8217;evoluzione di ISDN l&#8217;ha portato ad essere adottato in anbito aziendale. Queste ultime scelgono spesso tra due opzioni di installazione: il <em>multinumero</em> e la <em>selezione passante</em>.</p>

<h3>Multinumero</h3>

<p>E&#8217; un servizio opzionale.  <span class="blue-pen">Permette di avere un massimo di 8 terminali, sullo steso S-BUS, ognuno raggiungibile direttamente dall&#8217;esterno con un suo proprio numero telefonico</span>.</p>

<ul>
<li>Possibile solo su ISDN accesso base (BRI)</li>
<li>Solo due terminali possono essere attivi contemporaneamente</li>
<li>Non chiede l&#8217;installazione di un PBX</li>
<li>Le chiamate interne sono a pagamento</li>
<li>NT (Network Terminator) deve essere configurato punto-multipunto</li>
</ul>


<h3>Selezione Passante</h3>

<p>E&#8217; un servizio opzionale.  <span class="blue-pen">Permette di raggiungere direttamente i terminali interni appoggiandoci su un PBX (centralino telefonico). Non si ha il limite di 8 terminali su ogni linea ISDN</span>.</p>

<ul>
<li>Possibile sia su linee BRI, sia su linee PRI</li>
<li>Non c&#8217;è limite al numero di terminali interni attivi contemporaneamente</li>
<li>Chiede l&#8217;instllazione di un PBX</li>
<li>Le chiamate interne NON sono a pagamento</li>
<li>NT (Network Terminator) deve essere configurato punto-punto</li>
</ul>


<h3>Considerazioni</h3>

<p>Il multinumero si adatta solo in pochi casi&#8230; spesso perche&#8217; sono richieste telefonate interne gratuite!</p>

<p><span class="blue-pen"><br /> Ad esempio possiamo avere cinque ingressi ISDN: ipotizziamo i numeri telefonici da 02160291<span style="text-decoration: underline;">01</span> a 02160291<span style="text-decoration: underline;">05</span> (Le ultime due cifre individuano la linea fisica, e sono 5 BRI &#8211; quindi max 10 telefonate esterne contemporaneamente).<br /> Grazie alla selezione passante riusciamo ad avere i numeri da 02160291<span style="text-decoration: underline;">00</span> a 02160291<span style="text-decoration: underline;">99</span>&#8230; un range di ben 100 numero!<br /> </span></p>
]]></content>
  </entry>
  
</feed>
